"""
MCP Function handlers for launchdarkly_mcp_server.

This module contains all the handler functions that process MCP requests and make
HTTP requests to the underlying API at https://app.launchdarkly.com.
"""
import json
import logging
from typing import Dict, Any

import aiohttp
from mcp import McpError

import config

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("launchdarkly_mcp_server.handlers")

# Dictionary to hold all function handlers
function_handlers = {}

async def handle_getRoot(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getRoot MCP function.
    
    Makes an HTTP GET request to /api/v2.
    Root resource
    """
    logger.info(f"Handling getRoot with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getRoot"] = handle_getRoot
async def handle_getRelayProxyConfigs(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getRelayProxyConfigs MCP function.
    
    Makes an HTTP GET request to /api/v2/account/relay-auto-configs.
    List Relay Proxy configs
    """
    logger.info(f"Handling getRelayProxyConfigs with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/account/relay-auto-configs"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getRelayProxyConfigs"] = handle_getRelayProxyConfigs
async def handle_postRelayAutoConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postRelayAutoConfig MCP function.
    
    Makes an HTTP POST request to /api/v2/account/relay-auto-configs.
    Create a new Relay Proxy config
    """
    logger.info(f"Handling postRelayAutoConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/account/relay-auto-configs"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postRelayAutoConfig"] = handle_postRelayAutoConfig
async def handle_getRelayProxyConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getRelayProxyConfig MCP function.
    
    Makes an HTTP GET request to /api/v2/account/relay-auto-configs/{id}.
    Get Relay Proxy config
    """
    logger.info(f"Handling getRelayProxyConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/account/relay-auto-configs/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getRelayProxyConfig"] = handle_getRelayProxyConfig
async def handle_patchRelayAutoConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchRelayAutoConfig MCP function.
    
    Makes an HTTP PATCH request to /api/v2/account/relay-auto-configs/{id}.
    Update a Relay Proxy config
    """
    logger.info(f"Handling patchRelayAutoConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/account/relay-auto-configs/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchRelayAutoConfig"] = handle_patchRelayAutoConfig
async def handle_deleteRelayAutoConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteRelayAutoConfig MCP function.
    
    Makes an HTTP DELETE request to /api/v2/account/relay-auto-configs/{id}.
    Delete Relay Proxy config by ID
    """
    logger.info(f"Handling deleteRelayAutoConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/account/relay-auto-configs/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteRelayAutoConfig"] = handle_deleteRelayAutoConfig
async def handle_resetRelayAutoConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the resetRelayAutoConfig MCP function.
    
    Makes an HTTP POST request to /api/v2/account/relay-auto-configs/{id}/reset.
    Reset Relay Proxy configuration key
    """
    logger.info(f"Handling resetRelayAutoConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/account/relay-auto-configs/{id}/reset"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expiry" in params:
        query_params["expiry"] = params["expiry"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["resetRelayAutoConfig"] = handle_resetRelayAutoConfig
async def handle_getApplications(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getApplications MCP function.
    
    Makes an HTTP GET request to /api/v2/applications.
    Get applications
    """
    logger.info(f"Handling getApplications with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/applications"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getApplications"] = handle_getApplications
async def handle_getApplication(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getApplication MCP function.
    
    Makes an HTTP GET request to /api/v2/applications/{applicationKey}.
    Get application by key
    """
    logger.info(f"Handling getApplication with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/applications/{applicationKey}"
    # Replace path parameter {applicationKey}} with the value from params
    if "applicationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: applicationKey"
        )
    path = path.replace("{applicationKey}}", str(params["applicationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getApplication"] = handle_getApplication
async def handle_patchApplication(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchApplication MCP function.
    
    Makes an HTTP PATCH request to /api/v2/applications/{applicationKey}.
    Update application
    """
    logger.info(f"Handling patchApplication with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/applications/{applicationKey}"
    # Replace path parameter {applicationKey}} with the value from params
    if "applicationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: applicationKey"
        )
    path = path.replace("{applicationKey}}", str(params["applicationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchApplication"] = handle_patchApplication
async def handle_deleteApplication(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteApplication MCP function.
    
    Makes an HTTP DELETE request to /api/v2/applications/{applicationKey}.
    Delete application
    """
    logger.info(f"Handling deleteApplication with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/applications/{applicationKey}"
    # Replace path parameter {applicationKey}} with the value from params
    if "applicationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: applicationKey"
        )
    path = path.replace("{applicationKey}}", str(params["applicationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteApplication"] = handle_deleteApplication
async def handle_getApplicationVersions(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getApplicationVersions MCP function.
    
    Makes an HTTP GET request to /api/v2/applications/{applicationKey}/versions.
    Get application versions by application key
    """
    logger.info(f"Handling getApplicationVersions with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/applications/{applicationKey}/versions"
    # Replace path parameter {applicationKey}} with the value from params
    if "applicationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: applicationKey"
        )
    path = path.replace("{applicationKey}}", str(params["applicationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getApplicationVersions"] = handle_getApplicationVersions
async def handle_patchApplicationVersion(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchApplicationVersion MCP function.
    
    Makes an HTTP PATCH request to /api/v2/applications/{applicationKey}/versions/{versionKey}.
    Update application version
    """
    logger.info(f"Handling patchApplicationVersion with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/applications/{applicationKey}/versions/{versionKey}"
    # Replace path parameter {applicationKey}} with the value from params
    if "applicationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: applicationKey"
        )
    path = path.replace("{applicationKey}}", str(params["applicationKey"]))
    # Replace path parameter {versionKey}} with the value from params
    if "versionKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: versionKey"
        )
    path = path.replace("{versionKey}}", str(params["versionKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchApplicationVersion"] = handle_patchApplicationVersion
async def handle_deleteApplicationVersion(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteApplicationVersion MCP function.
    
    Makes an HTTP DELETE request to /api/v2/applications/{applicationKey}/versions/{versionKey}.
    Delete application version
    """
    logger.info(f"Handling deleteApplicationVersion with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/applications/{applicationKey}/versions/{versionKey}"
    # Replace path parameter {applicationKey}} with the value from params
    if "applicationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: applicationKey"
        )
    path = path.replace("{applicationKey}}", str(params["applicationKey"]))
    # Replace path parameter {versionKey}} with the value from params
    if "versionKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: versionKey"
        )
    path = path.replace("{versionKey}}", str(params["versionKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteApplicationVersion"] = handle_deleteApplicationVersion
async def handle_getApprovalRequests(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getApprovalRequests MCP function.
    
    Makes an HTTP GET request to /api/v2/approval-requests.
    List approval requests
    """
    logger.info(f"Handling getApprovalRequests with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/approval-requests"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getApprovalRequests"] = handle_getApprovalRequests
async def handle_postApprovalRequest(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postApprovalRequest MCP function.
    
    Makes an HTTP POST request to /api/v2/approval-requests.
    Create approval request
    """
    logger.info(f"Handling postApprovalRequest with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/approval-requests"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postApprovalRequest"] = handle_postApprovalRequest
async def handle_getApprovalRequest(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getApprovalRequest MCP function.
    
    Makes an HTTP GET request to /api/v2/approval-requests/{id}.
    Get approval request
    """
    logger.info(f"Handling getApprovalRequest with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/approval-requests/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getApprovalRequest"] = handle_getApprovalRequest
async def handle_patchApprovalRequest(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchApprovalRequest MCP function.
    
    Makes an HTTP PATCH request to /api/v2/approval-requests/{id}.
    Update approval request
    """
    logger.info(f"Handling patchApprovalRequest with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/approval-requests/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchApprovalRequest"] = handle_patchApprovalRequest
async def handle_deleteApprovalRequest(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteApprovalRequest MCP function.
    
    Makes an HTTP DELETE request to /api/v2/approval-requests/{id}.
    Delete approval request
    """
    logger.info(f"Handling deleteApprovalRequest with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/approval-requests/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteApprovalRequest"] = handle_deleteApprovalRequest
async def handle_postApprovalRequestApply(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postApprovalRequestApply MCP function.
    
    Makes an HTTP POST request to /api/v2/approval-requests/{id}/apply.
    Apply approval request
    """
    logger.info(f"Handling postApprovalRequestApply with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/approval-requests/{id}/apply"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postApprovalRequestApply"] = handle_postApprovalRequestApply
async def handle_postApprovalRequestReview(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postApprovalRequestReview MCP function.
    
    Makes an HTTP POST request to /api/v2/approval-requests/{id}/reviews.
    Review approval request
    """
    logger.info(f"Handling postApprovalRequestReview with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/approval-requests/{id}/reviews"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postApprovalRequestReview"] = handle_postApprovalRequestReview
async def handle_getAuditLogEntries(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAuditLogEntries MCP function.
    
    Makes an HTTP GET request to /api/v2/auditlog.
    List audit log entries
    """
    logger.info(f"Handling getAuditLogEntries with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/auditlog"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "before" in params:
        query_params["before"] = params["before"]
    if "after" in params:
        query_params["after"] = params["after"]
    if "q" in params:
        query_params["q"] = params["q"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "spec" in params:
        query_params["spec"] = params["spec"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAuditLogEntries"] = handle_getAuditLogEntries
async def handle_postAuditLogEntries(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postAuditLogEntries MCP function.
    
    Makes an HTTP POST request to /api/v2/auditlog.
    Search audit log entries
    """
    logger.info(f"Handling postAuditLogEntries with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/auditlog"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "before" in params:
        query_params["before"] = params["before"]
    if "after" in params:
        query_params["after"] = params["after"]
    if "q" in params:
        query_params["q"] = params["q"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postAuditLogEntries"] = handle_postAuditLogEntries
async def handle_getAuditLogEntry(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAuditLogEntry MCP function.
    
    Makes an HTTP GET request to /api/v2/auditlog/{id}.
    Get audit log entry
    """
    logger.info(f"Handling getAuditLogEntry with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/auditlog/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAuditLogEntry"] = handle_getAuditLogEntry
async def handle_getCallerIdentity(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getCallerIdentity MCP function.
    
    Makes an HTTP GET request to /api/v2/caller-identity.
    Identify the caller
    """
    logger.info(f"Handling getCallerIdentity with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/caller-identity"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getCallerIdentity"] = handle_getCallerIdentity
async def handle_getExtinctions(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExtinctions MCP function.
    
    Makes an HTTP GET request to /api/v2/code-refs/extinctions.
    List extinctions
    """
    logger.info(f"Handling getExtinctions with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/extinctions"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "repoName" in params:
        query_params["repoName"] = params["repoName"]
    if "branchName" in params:
        query_params["branchName"] = params["branchName"]
    if "projKey" in params:
        query_params["projKey"] = params["projKey"]
    if "flagKey" in params:
        query_params["flagKey"] = params["flagKey"]
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExtinctions"] = handle_getExtinctions
async def handle_getRepositories(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getRepositories MCP function.
    
    Makes an HTTP GET request to /api/v2/code-refs/repositories.
    List repositories
    """
    logger.info(f"Handling getRepositories with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/repositories"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "withBranches" in params:
        query_params["withBranches"] = params["withBranches"]
    if "withReferencesForDefaultBranch" in params:
        query_params["withReferencesForDefaultBranch"] = params["withReferencesForDefaultBranch"]
    if "projKey" in params:
        query_params["projKey"] = params["projKey"]
    if "flagKey" in params:
        query_params["flagKey"] = params["flagKey"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getRepositories"] = handle_getRepositories
async def handle_postRepository(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postRepository MCP function.
    
    Makes an HTTP POST request to /api/v2/code-refs/repositories.
    Create repository
    """
    logger.info(f"Handling postRepository with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/repositories"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postRepository"] = handle_postRepository
async def handle_getRepository(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getRepository MCP function.
    
    Makes an HTTP GET request to /api/v2/code-refs/repositories/{repo}.
    Get repository
    """
    logger.info(f"Handling getRepository with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/repositories/{repo}"
    # Replace path parameter {repo}} with the value from params
    if "repo" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: repo"
        )
    path = path.replace("{repo}}", str(params["repo"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getRepository"] = handle_getRepository
async def handle_patchRepository(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchRepository MCP function.
    
    Makes an HTTP PATCH request to /api/v2/code-refs/repositories/{repo}.
    Update repository
    """
    logger.info(f"Handling patchRepository with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/repositories/{repo}"
    # Replace path parameter {repo}} with the value from params
    if "repo" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: repo"
        )
    path = path.replace("{repo}}", str(params["repo"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchRepository"] = handle_patchRepository
async def handle_deleteRepository(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteRepository MCP function.
    
    Makes an HTTP DELETE request to /api/v2/code-refs/repositories/{repo}.
    Delete repository
    """
    logger.info(f"Handling deleteRepository with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/repositories/{repo}"
    # Replace path parameter {repo}} with the value from params
    if "repo" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: repo"
        )
    path = path.replace("{repo}}", str(params["repo"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteRepository"] = handle_deleteRepository
async def handle_deleteBranches(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteBranches MCP function.
    
    Makes an HTTP POST request to /api/v2/code-refs/repositories/{repo}/branch-delete-tasks.
    Delete branches
    """
    logger.info(f"Handling deleteBranches with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/repositories/{repo}/branch-delete-tasks"
    # Replace path parameter {repo}} with the value from params
    if "repo" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: repo"
        )
    path = path.replace("{repo}}", str(params["repo"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteBranches"] = handle_deleteBranches
async def handle_getBranches(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getBranches MCP function.
    
    Makes an HTTP GET request to /api/v2/code-refs/repositories/{repo}/branches.
    List branches
    """
    logger.info(f"Handling getBranches with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/repositories/{repo}/branches"
    # Replace path parameter {repo}} with the value from params
    if "repo" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: repo"
        )
    path = path.replace("{repo}}", str(params["repo"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getBranches"] = handle_getBranches
async def handle_getBranch(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getBranch MCP function.
    
    Makes an HTTP GET request to /api/v2/code-refs/repositories/{repo}/branches/{branch}.
    Get branch
    """
    logger.info(f"Handling getBranch with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/repositories/{repo}/branches/{branch}"
    # Replace path parameter {repo}} with the value from params
    if "repo" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: repo"
        )
    path = path.replace("{repo}}", str(params["repo"]))
    # Replace path parameter {branch}} with the value from params
    if "branch" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: branch"
        )
    path = path.replace("{branch}}", str(params["branch"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "projKey" in params:
        query_params["projKey"] = params["projKey"]
    if "flagKey" in params:
        query_params["flagKey"] = params["flagKey"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getBranch"] = handle_getBranch
async def handle_putBranch(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the putBranch MCP function.
    
    Makes an HTTP PUT request to /api/v2/code-refs/repositories/{repo}/branches/{branch}.
    Upsert branch
    """
    logger.info(f"Handling putBranch with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/repositories/{repo}/branches/{branch}"
    # Replace path parameter {repo}} with the value from params
    if "repo" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: repo"
        )
    path = path.replace("{repo}}", str(params["repo"]))
    # Replace path parameter {branch}} with the value from params
    if "branch" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: branch"
        )
    path = path.replace("{branch}}", str(params["branch"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["putBranch"] = handle_putBranch
async def handle_postExtinction(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postExtinction MCP function.
    
    Makes an HTTP POST request to /api/v2/code-refs/repositories/{repo}/branches/{branch}/extinction-events.
    Create extinction
    """
    logger.info(f"Handling postExtinction with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/repositories/{repo}/branches/{branch}/extinction-events"
    # Replace path parameter {repo}} with the value from params
    if "repo" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: repo"
        )
    path = path.replace("{repo}}", str(params["repo"]))
    # Replace path parameter {branch}} with the value from params
    if "branch" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: branch"
        )
    path = path.replace("{branch}}", str(params["branch"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postExtinction"] = handle_postExtinction
async def handle_getRootStatistic(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getRootStatistic MCP function.
    
    Makes an HTTP GET request to /api/v2/code-refs/statistics.
    Get links to code reference repositories for each project
    """
    logger.info(f"Handling getRootStatistic with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/statistics"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getRootStatistic"] = handle_getRootStatistic
async def handle_getStatistics(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getStatistics MCP function.
    
    Makes an HTTP GET request to /api/v2/code-refs/statistics/{projectKey}.
    Get code references statistics for flags
    """
    logger.info(f"Handling getStatistics with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/code-refs/statistics/{projectKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "flagKey" in params:
        query_params["flagKey"] = params["flagKey"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getStatistics"] = handle_getStatistics
async def handle_getDestinations(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getDestinations MCP function.
    
    Makes an HTTP GET request to /api/v2/destinations.
    List destinations
    """
    logger.info(f"Handling getDestinations with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/destinations"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getDestinations"] = handle_getDestinations
async def handle_postGenerateWarehouseDestinationKeyPair(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postGenerateWarehouseDestinationKeyPair MCP function.
    
    Makes an HTTP POST request to /api/v2/destinations/generate-warehouse-destination-key-pair.
    Generate Snowflake destination key pair
    """
    logger.info(f"Handling postGenerateWarehouseDestinationKeyPair with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/destinations/generate-warehouse-destination-key-pair"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postGenerateWarehouseDestinationKeyPair"] = handle_postGenerateWarehouseDestinationKeyPair
async def handle_postDestination(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postDestination MCP function.
    
    Makes an HTTP POST request to /api/v2/destinations/{projectKey}/{environmentKey}.
    Create Data Export destination
    """
    logger.info(f"Handling postDestination with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/destinations/{projectKey}/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postDestination"] = handle_postDestination
async def handle_getDestination(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getDestination MCP function.
    
    Makes an HTTP GET request to /api/v2/destinations/{projectKey}/{environmentKey}/{id}.
    Get destination
    """
    logger.info(f"Handling getDestination with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/destinations/{projectKey}/{environmentKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getDestination"] = handle_getDestination
async def handle_patchDestination(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchDestination MCP function.
    
    Makes an HTTP PATCH request to /api/v2/destinations/{projectKey}/{environmentKey}/{id}.
    Update Data Export destination
    """
    logger.info(f"Handling patchDestination with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/destinations/{projectKey}/{environmentKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchDestination"] = handle_patchDestination
async def handle_deleteDestination(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteDestination MCP function.
    
    Makes an HTTP DELETE request to /api/v2/destinations/{projectKey}/{environmentKey}/{id}.
    Delete Data Export destination
    """
    logger.info(f"Handling deleteDestination with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/destinations/{projectKey}/{environmentKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteDestination"] = handle_deleteDestination
async def handle_getFlagLinks(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFlagLinks MCP function.
    
    Makes an HTTP GET request to /api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}.
    List flag links
    """
    logger.info(f"Handling getFlagLinks with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFlagLinks"] = handle_getFlagLinks
async def handle_createFlagLink(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createFlagLink MCP function.
    
    Makes an HTTP POST request to /api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}.
    Create flag link
    """
    logger.info(f"Handling createFlagLink with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createFlagLink"] = handle_createFlagLink
async def handle_updateFlagLink(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the updateFlagLink MCP function.
    
    Makes an HTTP PATCH request to /api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}/{id}.
    Update flag link
    """
    logger.info(f"Handling updateFlagLink with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["updateFlagLink"] = handle_updateFlagLink
async def handle_deleteFlagLink(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteFlagLink MCP function.
    
    Makes an HTTP DELETE request to /api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}/{id}.
    Delete flag link
    """
    logger.info(f"Handling deleteFlagLink with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteFlagLink"] = handle_deleteFlagLink
async def handle_getFeatureFlagStatusAcrossEnvironments(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFeatureFlagStatusAcrossEnvironments MCP function.
    
    Makes an HTTP GET request to /api/v2/flag-status/{projectKey}/{featureFlagKey}.
    Get flag status across environments
    """
    logger.info(f"Handling getFeatureFlagStatusAcrossEnvironments with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flag-status/{projectKey}/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "env" in params:
        query_params["env"] = params["env"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFeatureFlagStatusAcrossEnvironments"] = handle_getFeatureFlagStatusAcrossEnvironments
async def handle_getFeatureFlagStatuses(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFeatureFlagStatuses MCP function.
    
    Makes an HTTP GET request to /api/v2/flag-statuses/{projectKey}/{environmentKey}.
    List feature flag statuses
    """
    logger.info(f"Handling getFeatureFlagStatuses with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flag-statuses/{projectKey}/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFeatureFlagStatuses"] = handle_getFeatureFlagStatuses
async def handle_getFeatureFlagStatus(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFeatureFlagStatus MCP function.
    
    Makes an HTTP GET request to /api/v2/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}.
    Get feature flag status
    """
    logger.info(f"Handling getFeatureFlagStatus with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFeatureFlagStatus"] = handle_getFeatureFlagStatus
async def handle_getFeatureFlags(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFeatureFlags MCP function.
    
    Makes an HTTP GET request to /api/v2/flags/{projectKey}.
    List feature flags
    """
    logger.info(f"Handling getFeatureFlags with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "env" in params:
        query_params["env"] = params["env"]
    if "tag" in params:
        query_params["tag"] = params["tag"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "archived" in params:
        query_params["archived"] = params["archived"]
    if "summary" in params:
        query_params["summary"] = params["summary"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "compare" in params:
        query_params["compare"] = params["compare"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFeatureFlags"] = handle_getFeatureFlags
async def handle_postFeatureFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postFeatureFlag MCP function.
    
    Makes an HTTP POST request to /api/v2/flags/{projectKey}.
    Create a feature flag
    """
    logger.info(f"Handling postFeatureFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "clone" in params:
        query_params["clone"] = params["clone"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postFeatureFlag"] = handle_postFeatureFlag
async def handle_getDependentFlagsByEnv(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getDependentFlagsByEnv MCP function.
    
    Makes an HTTP GET request to /api/v2/flags/{projectKey}/{environmentKey}/{featureFlagKey}/dependent-flags.
    List dependent feature flags by environment
    """
    logger.info(f"Handling getDependentFlagsByEnv with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{environmentKey}/{featureFlagKey}/dependent-flags"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getDependentFlagsByEnv"] = handle_getDependentFlagsByEnv
async def handle_getFeatureFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFeatureFlag MCP function.
    
    Makes an HTTP GET request to /api/v2/flags/{projectKey}/{featureFlagKey}.
    Get feature flag
    """
    logger.info(f"Handling getFeatureFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "env" in params:
        query_params["env"] = params["env"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFeatureFlag"] = handle_getFeatureFlag
async def handle_patchFeatureFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchFeatureFlag MCP function.
    
    Makes an HTTP PATCH request to /api/v2/flags/{projectKey}/{featureFlagKey}.
    Update feature flag
    """
    logger.info(f"Handling patchFeatureFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "ignoreConflicts" in params:
        query_params["ignoreConflicts"] = params["ignoreConflicts"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchFeatureFlag"] = handle_patchFeatureFlag
async def handle_deleteFeatureFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteFeatureFlag MCP function.
    
    Makes an HTTP DELETE request to /api/v2/flags/{projectKey}/{featureFlagKey}.
    Delete feature flag
    """
    logger.info(f"Handling deleteFeatureFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteFeatureFlag"] = handle_deleteFeatureFlag
async def handle_copyFeatureFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the copyFeatureFlag MCP function.
    
    Makes an HTTP POST request to /api/v2/flags/{projectKey}/{featureFlagKey}/copy.
    Copy feature flag
    """
    logger.info(f"Handling copyFeatureFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/copy"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["copyFeatureFlag"] = handle_copyFeatureFlag
async def handle_getDependentFlags(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getDependentFlags MCP function.
    
    Makes an HTTP GET request to /api/v2/flags/{projectKey}/{featureFlagKey}/dependent-flags.
    List dependent feature flags
    """
    logger.info(f"Handling getDependentFlags with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/dependent-flags"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getDependentFlags"] = handle_getDependentFlags
async def handle_getExpiringContextTargets(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExpiringContextTargets MCP function.
    
    Makes an HTTP GET request to /api/v2/flags/{projectKey}/{featureFlagKey}/expiring-targets/{environmentKey}.
    Get expiring context targets for feature flag
    """
    logger.info(f"Handling getExpiringContextTargets with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-targets/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExpiringContextTargets"] = handle_getExpiringContextTargets
async def handle_patchExpiringTargets(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchExpiringTargets MCP function.
    
    Makes an HTTP PATCH request to /api/v2/flags/{projectKey}/{featureFlagKey}/expiring-targets/{environmentKey}.
    Update expiring context targets on feature flag
    """
    logger.info(f"Handling patchExpiringTargets with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-targets/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchExpiringTargets"] = handle_patchExpiringTargets
async def handle_getExpiringUserTargets(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExpiringUserTargets MCP function.
    
    Makes an HTTP GET request to /api/v2/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}.
    Get expiring user targets for feature flag
    """
    logger.info(f"Handling getExpiringUserTargets with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExpiringUserTargets"] = handle_getExpiringUserTargets
async def handle_patchExpiringUserTargets(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchExpiringUserTargets MCP function.
    
    Makes an HTTP PATCH request to /api/v2/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}.
    Update expiring user targets on feature flag
    """
    logger.info(f"Handling patchExpiringUserTargets with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchExpiringUserTargets"] = handle_patchExpiringUserTargets
async def handle_getTriggerWorkflows(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getTriggerWorkflows MCP function.
    
    Makes an HTTP GET request to /api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}.
    List flag triggers
    """
    logger.info(f"Handling getTriggerWorkflows with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getTriggerWorkflows"] = handle_getTriggerWorkflows
async def handle_createTriggerWorkflow(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createTriggerWorkflow MCP function.
    
    Makes an HTTP POST request to /api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}.
    Create flag trigger
    """
    logger.info(f"Handling createTriggerWorkflow with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createTriggerWorkflow"] = handle_createTriggerWorkflow
async def handle_getTriggerWorkflowById(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getTriggerWorkflowById MCP function.
    
    Makes an HTTP GET request to /api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}.
    Get flag trigger by ID
    """
    logger.info(f"Handling getTriggerWorkflowById with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getTriggerWorkflowById"] = handle_getTriggerWorkflowById
async def handle_patchTriggerWorkflow(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchTriggerWorkflow MCP function.
    
    Makes an HTTP PATCH request to /api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}.
    Update flag trigger
    """
    logger.info(f"Handling patchTriggerWorkflow with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchTriggerWorkflow"] = handle_patchTriggerWorkflow
async def handle_deleteTriggerWorkflow(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteTriggerWorkflow MCP function.
    
    Makes an HTTP DELETE request to /api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}.
    Delete flag trigger
    """
    logger.info(f"Handling deleteTriggerWorkflow with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteTriggerWorkflow"] = handle_deleteTriggerWorkflow
async def handle_getReleaseByFlagKey(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getReleaseByFlagKey MCP function.
    
    Makes an HTTP GET request to /api/v2/flags/{projectKey}/{flagKey}/release.
    Get release for flag
    """
    logger.info(f"Handling getReleaseByFlagKey with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{flagKey}/release"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {flagKey}} with the value from params
    if "flagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: flagKey"
        )
    path = path.replace("{flagKey}}", str(params["flagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getReleaseByFlagKey"] = handle_getReleaseByFlagKey
async def handle_patchReleaseByFlagKey(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchReleaseByFlagKey MCP function.
    
    Makes an HTTP PATCH request to /api/v2/flags/{projectKey}/{flagKey}/release.
    Patch release for flag
    """
    logger.info(f"Handling patchReleaseByFlagKey with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{flagKey}/release"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {flagKey}} with the value from params
    if "flagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: flagKey"
        )
    path = path.replace("{flagKey}}", str(params["flagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchReleaseByFlagKey"] = handle_patchReleaseByFlagKey
async def handle_deleteReleaseByFlagKey(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteReleaseByFlagKey MCP function.
    
    Makes an HTTP DELETE request to /api/v2/flags/{projectKey}/{flagKey}/release.
    Delete a release for flag
    """
    logger.info(f"Handling deleteReleaseByFlagKey with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/flags/{projectKey}/{flagKey}/release"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {flagKey}} with the value from params
    if "flagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: flagKey"
        )
    path = path.replace("{flagKey}}", str(params["flagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteReleaseByFlagKey"] = handle_deleteReleaseByFlagKey
async def handle_getBigSegmentStoreIntegrations(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getBigSegmentStoreIntegrations MCP function.
    
    Makes an HTTP GET request to /api/v2/integration-capabilities/big-segment-store.
    List all big segment store integrations
    """
    logger.info(f"Handling getBigSegmentStoreIntegrations with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/big-segment-store"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getBigSegmentStoreIntegrations"] = handle_getBigSegmentStoreIntegrations
async def handle_createBigSegmentStoreIntegration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createBigSegmentStoreIntegration MCP function.
    
    Makes an HTTP POST request to /api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}.
    Create big segment store integration
    """
    logger.info(f"Handling createBigSegmentStoreIntegration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createBigSegmentStoreIntegration"] = handle_createBigSegmentStoreIntegration
async def handle_getBigSegmentStoreIntegration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getBigSegmentStoreIntegration MCP function.
    
    Makes an HTTP GET request to /api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}.
    Get big segment store integration by ID
    """
    logger.info(f"Handling getBigSegmentStoreIntegration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {integrationId}} with the value from params
    if "integrationId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationId"
        )
    path = path.replace("{integrationId}}", str(params["integrationId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getBigSegmentStoreIntegration"] = handle_getBigSegmentStoreIntegration
async def handle_patchBigSegmentStoreIntegration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchBigSegmentStoreIntegration MCP function.
    
    Makes an HTTP PATCH request to /api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}.
    Update big segment store integration
    """
    logger.info(f"Handling patchBigSegmentStoreIntegration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {integrationId}} with the value from params
    if "integrationId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationId"
        )
    path = path.replace("{integrationId}}", str(params["integrationId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchBigSegmentStoreIntegration"] = handle_patchBigSegmentStoreIntegration
async def handle_deleteBigSegmentStoreIntegration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteBigSegmentStoreIntegration MCP function.
    
    Makes an HTTP DELETE request to /api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}.
    Delete big segment store integration
    """
    logger.info(f"Handling deleteBigSegmentStoreIntegration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {integrationId}} with the value from params
    if "integrationId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationId"
        )
    path = path.replace("{integrationId}}", str(params["integrationId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteBigSegmentStoreIntegration"] = handle_deleteBigSegmentStoreIntegration
async def handle_getIntegrationDeliveryConfigurations(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getIntegrationDeliveryConfigurations MCP function.
    
    Makes an HTTP GET request to /api/v2/integration-capabilities/featureStore.
    List all delivery configurations
    """
    logger.info(f"Handling getIntegrationDeliveryConfigurations with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/featureStore"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getIntegrationDeliveryConfigurations"] = handle_getIntegrationDeliveryConfigurations
async def handle_getIntegrationDeliveryConfigurationByEnvironment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getIntegrationDeliveryConfigurationByEnvironment MCP function.
    
    Makes an HTTP GET request to /api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}.
    Get delivery configurations by environment
    """
    logger.info(f"Handling getIntegrationDeliveryConfigurationByEnvironment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getIntegrationDeliveryConfigurationByEnvironment"] = handle_getIntegrationDeliveryConfigurationByEnvironment
async def handle_createIntegrationDeliveryConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createIntegrationDeliveryConfiguration MCP function.
    
    Makes an HTTP POST request to /api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}.
    Create delivery configuration
    """
    logger.info(f"Handling createIntegrationDeliveryConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createIntegrationDeliveryConfiguration"] = handle_createIntegrationDeliveryConfiguration
async def handle_getIntegrationDeliveryConfigurationById(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getIntegrationDeliveryConfigurationById MCP function.
    
    Makes an HTTP GET request to /api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}.
    Get delivery configuration by ID
    """
    logger.info(f"Handling getIntegrationDeliveryConfigurationById with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getIntegrationDeliveryConfigurationById"] = handle_getIntegrationDeliveryConfigurationById
async def handle_patchIntegrationDeliveryConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchIntegrationDeliveryConfiguration MCP function.
    
    Makes an HTTP PATCH request to /api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}.
    Update delivery configuration
    """
    logger.info(f"Handling patchIntegrationDeliveryConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchIntegrationDeliveryConfiguration"] = handle_patchIntegrationDeliveryConfiguration
async def handle_deleteIntegrationDeliveryConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteIntegrationDeliveryConfiguration MCP function.
    
    Makes an HTTP DELETE request to /api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}.
    Delete delivery configuration
    """
    logger.info(f"Handling deleteIntegrationDeliveryConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteIntegrationDeliveryConfiguration"] = handle_deleteIntegrationDeliveryConfiguration
async def handle_validateIntegrationDeliveryConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the validateIntegrationDeliveryConfiguration MCP function.
    
    Makes an HTTP POST request to /api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}/validate.
    Validate delivery configuration
    """
    logger.info(f"Handling validateIntegrationDeliveryConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}/validate"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["validateIntegrationDeliveryConfiguration"] = handle_validateIntegrationDeliveryConfiguration
async def handle_getFlagImportConfigurations(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFlagImportConfigurations MCP function.
    
    Makes an HTTP GET request to /api/v2/integration-capabilities/flag-import.
    List all flag import configurations
    """
    logger.info(f"Handling getFlagImportConfigurations with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/flag-import"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFlagImportConfigurations"] = handle_getFlagImportConfigurations
async def handle_createFlagImportConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createFlagImportConfiguration MCP function.
    
    Makes an HTTP POST request to /api/v2/integration-capabilities/flag-import/{projectKey}/{integrationKey}.
    Create a flag import configuration
    """
    logger.info(f"Handling createFlagImportConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/flag-import/{projectKey}/{integrationKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createFlagImportConfiguration"] = handle_createFlagImportConfiguration
async def handle_getFlagImportConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFlagImportConfiguration MCP function.
    
    Makes an HTTP GET request to /api/v2/integration-capabilities/flag-import/{projectKey}/{integrationKey}/{integrationId}.
    Get a single flag import configuration
    """
    logger.info(f"Handling getFlagImportConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/flag-import/{projectKey}/{integrationKey}/{integrationId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {integrationId}} with the value from params
    if "integrationId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationId"
        )
    path = path.replace("{integrationId}}", str(params["integrationId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFlagImportConfiguration"] = handle_getFlagImportConfiguration
async def handle_patchFlagImportConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchFlagImportConfiguration MCP function.
    
    Makes an HTTP PATCH request to /api/v2/integration-capabilities/flag-import/{projectKey}/{integrationKey}/{integrationId}.
    Update a flag import configuration
    """
    logger.info(f"Handling patchFlagImportConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/flag-import/{projectKey}/{integrationKey}/{integrationId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {integrationId}} with the value from params
    if "integrationId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationId"
        )
    path = path.replace("{integrationId}}", str(params["integrationId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchFlagImportConfiguration"] = handle_patchFlagImportConfiguration
async def handle_deleteFlagImportConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteFlagImportConfiguration MCP function.
    
    Makes an HTTP DELETE request to /api/v2/integration-capabilities/flag-import/{projectKey}/{integrationKey}/{integrationId}.
    Delete a flag import configuration
    """
    logger.info(f"Handling deleteFlagImportConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/flag-import/{projectKey}/{integrationKey}/{integrationId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {integrationId}} with the value from params
    if "integrationId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationId"
        )
    path = path.replace("{integrationId}}", str(params["integrationId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteFlagImportConfiguration"] = handle_deleteFlagImportConfiguration
async def handle_triggerFlagImportJob(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the triggerFlagImportJob MCP function.
    
    Makes an HTTP POST request to /api/v2/integration-capabilities/flag-import/{projectKey}/{integrationKey}/{integrationId}/trigger.
    Trigger a single flag import run
    """
    logger.info(f"Handling triggerFlagImportJob with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-capabilities/flag-import/{projectKey}/{integrationKey}/{integrationId}/trigger"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {integrationId}} with the value from params
    if "integrationId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationId"
        )
    path = path.replace("{integrationId}}", str(params["integrationId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["triggerFlagImportJob"] = handle_triggerFlagImportJob
async def handle_getAllIntegrationConfigurations(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAllIntegrationConfigurations MCP function.
    
    Makes an HTTP GET request to /api/v2/integration-configurations/keys/{integrationKey}.
    Get all configurations for the integration
    """
    logger.info(f"Handling getAllIntegrationConfigurations with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-configurations/keys/{integrationKey}"
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAllIntegrationConfigurations"] = handle_getAllIntegrationConfigurations
async def handle_createIntegrationConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createIntegrationConfiguration MCP function.
    
    Makes an HTTP POST request to /api/v2/integration-configurations/keys/{integrationKey}.
    Create integration configuration
    """
    logger.info(f"Handling createIntegrationConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-configurations/keys/{integrationKey}"
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createIntegrationConfiguration"] = handle_createIntegrationConfiguration
async def handle_getIntegrationConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getIntegrationConfiguration MCP function.
    
    Makes an HTTP GET request to /api/v2/integration-configurations/{integrationConfigurationId}.
    Get an integration configuration
    """
    logger.info(f"Handling getIntegrationConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-configurations/{integrationConfigurationId}"
    # Replace path parameter {integrationConfigurationId}} with the value from params
    if "integrationConfigurationId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationConfigurationId"
        )
    path = path.replace("{integrationConfigurationId}}", str(params["integrationConfigurationId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getIntegrationConfiguration"] = handle_getIntegrationConfiguration
async def handle_updateIntegrationConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the updateIntegrationConfiguration MCP function.
    
    Makes an HTTP PATCH request to /api/v2/integration-configurations/{integrationConfigurationId}.
    Update integration configuration
    """
    logger.info(f"Handling updateIntegrationConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-configurations/{integrationConfigurationId}"
    # Replace path parameter {integrationConfigurationId}} with the value from params
    if "integrationConfigurationId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationConfigurationId"
        )
    path = path.replace("{integrationConfigurationId}}", str(params["integrationConfigurationId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["updateIntegrationConfiguration"] = handle_updateIntegrationConfiguration
async def handle_deleteIntegrationConfiguration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteIntegrationConfiguration MCP function.
    
    Makes an HTTP DELETE request to /api/v2/integration-configurations/{integrationConfigurationId}.
    Delete integration configuration
    """
    logger.info(f"Handling deleteIntegrationConfiguration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integration-configurations/{integrationConfigurationId}"
    # Replace path parameter {integrationConfigurationId}} with the value from params
    if "integrationConfigurationId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationConfigurationId"
        )
    path = path.replace("{integrationConfigurationId}}", str(params["integrationConfigurationId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteIntegrationConfiguration"] = handle_deleteIntegrationConfiguration
async def handle_getSubscriptions(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getSubscriptions MCP function.
    
    Makes an HTTP GET request to /api/v2/integrations/{integrationKey}.
    Get audit log subscriptions by integration
    """
    logger.info(f"Handling getSubscriptions with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integrations/{integrationKey}"
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getSubscriptions"] = handle_getSubscriptions
async def handle_createSubscription(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createSubscription MCP function.
    
    Makes an HTTP POST request to /api/v2/integrations/{integrationKey}.
    Create audit log subscription
    """
    logger.info(f"Handling createSubscription with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integrations/{integrationKey}"
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createSubscription"] = handle_createSubscription
async def handle_getSubscriptionByID(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getSubscriptionByID MCP function.
    
    Makes an HTTP GET request to /api/v2/integrations/{integrationKey}/{id}.
    Get audit log subscription by ID
    """
    logger.info(f"Handling getSubscriptionByID with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integrations/{integrationKey}/{id}"
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getSubscriptionByID"] = handle_getSubscriptionByID
async def handle_updateSubscription(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the updateSubscription MCP function.
    
    Makes an HTTP PATCH request to /api/v2/integrations/{integrationKey}/{id}.
    Update audit log subscription
    """
    logger.info(f"Handling updateSubscription with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integrations/{integrationKey}/{id}"
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["updateSubscription"] = handle_updateSubscription
async def handle_deleteSubscription(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteSubscription MCP function.
    
    Makes an HTTP DELETE request to /api/v2/integrations/{integrationKey}/{id}.
    Delete audit log subscription
    """
    logger.info(f"Handling deleteSubscription with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/integrations/{integrationKey}/{id}"
    # Replace path parameter {integrationKey}} with the value from params
    if "integrationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: integrationKey"
        )
    path = path.replace("{integrationKey}}", str(params["integrationKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteSubscription"] = handle_deleteSubscription
async def handle_getMembers(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getMembers MCP function.
    
    Makes an HTTP GET request to /api/v2/members.
    List account members
    """
    logger.info(f"Handling getMembers with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/members"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getMembers"] = handle_getMembers
async def handle_postMembers(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postMembers MCP function.
    
    Makes an HTTP POST request to /api/v2/members.
    Invite new members
    """
    logger.info(f"Handling postMembers with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/members"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postMembers"] = handle_postMembers
async def handle_patchMembers(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchMembers MCP function.
    
    Makes an HTTP PATCH request to /api/v2/members.
    Modify account members
    """
    logger.info(f"Handling patchMembers with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/members"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchMembers"] = handle_patchMembers
async def handle_getMember(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getMember MCP function.
    
    Makes an HTTP GET request to /api/v2/members/{id}.
    Get account member
    """
    logger.info(f"Handling getMember with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/members/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getMember"] = handle_getMember
async def handle_patchMember(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchMember MCP function.
    
    Makes an HTTP PATCH request to /api/v2/members/{id}.
    Modify an account member
    """
    logger.info(f"Handling patchMember with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/members/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchMember"] = handle_patchMember
async def handle_deleteMember(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteMember MCP function.
    
    Makes an HTTP DELETE request to /api/v2/members/{id}.
    Delete account member
    """
    logger.info(f"Handling deleteMember with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/members/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteMember"] = handle_deleteMember
async def handle_postMemberTeams(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postMemberTeams MCP function.
    
    Makes an HTTP POST request to /api/v2/members/{id}/teams.
    Add a member to teams
    """
    logger.info(f"Handling postMemberTeams with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/members/{id}/teams"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postMemberTeams"] = handle_postMemberTeams
async def handle_getMetrics(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getMetrics MCP function.
    
    Makes an HTTP GET request to /api/v2/metrics/{projectKey}.
    List metrics
    """
    logger.info(f"Handling getMetrics with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/metrics/{projectKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getMetrics"] = handle_getMetrics
async def handle_postMetric(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postMetric MCP function.
    
    Makes an HTTP POST request to /api/v2/metrics/{projectKey}.
    Create metric
    """
    logger.info(f"Handling postMetric with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/metrics/{projectKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postMetric"] = handle_postMetric
async def handle_getMetric(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getMetric MCP function.
    
    Makes an HTTP GET request to /api/v2/metrics/{projectKey}/{metricKey}.
    Get metric
    """
    logger.info(f"Handling getMetric with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/metrics/{projectKey}/{metricKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {metricKey}} with the value from params
    if "metricKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: metricKey"
        )
    path = path.replace("{metricKey}}", str(params["metricKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    if "versionId" in params:
        query_params["versionId"] = params["versionId"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getMetric"] = handle_getMetric
async def handle_patchMetric(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchMetric MCP function.
    
    Makes an HTTP PATCH request to /api/v2/metrics/{projectKey}/{metricKey}.
    Update metric
    """
    logger.info(f"Handling patchMetric with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/metrics/{projectKey}/{metricKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {metricKey}} with the value from params
    if "metricKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: metricKey"
        )
    path = path.replace("{metricKey}}", str(params["metricKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchMetric"] = handle_patchMetric
async def handle_deleteMetric(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteMetric MCP function.
    
    Makes an HTTP DELETE request to /api/v2/metrics/{projectKey}/{metricKey}.
    Delete metric
    """
    logger.info(f"Handling deleteMetric with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/metrics/{projectKey}/{metricKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {metricKey}} with the value from params
    if "metricKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: metricKey"
        )
    path = path.replace("{metricKey}}", str(params["metricKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteMetric"] = handle_deleteMetric
async def handle_getOAuthClients(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getOAuthClients MCP function.
    
    Makes an HTTP GET request to /api/v2/oauth/clients.
    Get clients
    """
    logger.info(f"Handling getOAuthClients with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/oauth/clients"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getOAuthClients"] = handle_getOAuthClients
async def handle_createOAuth2Client(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createOAuth2Client MCP function.
    
    Makes an HTTP POST request to /api/v2/oauth/clients.
    Create a LaunchDarkly OAuth 2.0 client
    """
    logger.info(f"Handling createOAuth2Client with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/oauth/clients"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createOAuth2Client"] = handle_createOAuth2Client
async def handle_getOAuthClientById(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getOAuthClientById MCP function.
    
    Makes an HTTP GET request to /api/v2/oauth/clients/{clientId}.
    Get client by ID
    """
    logger.info(f"Handling getOAuthClientById with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/oauth/clients/{clientId}"
    # Replace path parameter {clientId}} with the value from params
    if "clientId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: clientId"
        )
    path = path.replace("{clientId}}", str(params["clientId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getOAuthClientById"] = handle_getOAuthClientById
async def handle_patchOAuthClient(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchOAuthClient MCP function.
    
    Makes an HTTP PATCH request to /api/v2/oauth/clients/{clientId}.
    Patch client by ID
    """
    logger.info(f"Handling patchOAuthClient with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/oauth/clients/{clientId}"
    # Replace path parameter {clientId}} with the value from params
    if "clientId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: clientId"
        )
    path = path.replace("{clientId}}", str(params["clientId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchOAuthClient"] = handle_patchOAuthClient
async def handle_deleteOAuthClient(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteOAuthClient MCP function.
    
    Makes an HTTP DELETE request to /api/v2/oauth/clients/{clientId}.
    Delete OAuth 2.0 client
    """
    logger.info(f"Handling deleteOAuthClient with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/oauth/clients/{clientId}"
    # Replace path parameter {clientId}} with the value from params
    if "clientId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: clientId"
        )
    path = path.replace("{clientId}}", str(params["clientId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteOAuthClient"] = handle_deleteOAuthClient
async def handle_getOpenapiSpec(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getOpenapiSpec MCP function.
    
    Makes an HTTP GET request to /api/v2/openapi.json.
    Gets the OpenAPI spec in json
    """
    logger.info(f"Handling getOpenapiSpec with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/openapi.json"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getOpenapiSpec"] = handle_getOpenapiSpec
async def handle_getProjects(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getProjects MCP function.
    
    Makes an HTTP GET request to /api/v2/projects.
    List projects
    """
    logger.info(f"Handling getProjects with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getProjects"] = handle_getProjects
async def handle_postProject(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postProject MCP function.
    
    Makes an HTTP POST request to /api/v2/projects.
    Create project
    """
    logger.info(f"Handling postProject with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postProject"] = handle_postProject
async def handle_getProject(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getProject MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}.
    Get project
    """
    logger.info(f"Handling getProject with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getProject"] = handle_getProject
async def handle_patchProject(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchProject MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}.
    Update project
    """
    logger.info(f"Handling patchProject with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchProject"] = handle_patchProject
async def handle_deleteProject(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteProject MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}.
    Delete project
    """
    logger.info(f"Handling deleteProject with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteProject"] = handle_deleteProject
async def handle_getContextKindsByProjectKey(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getContextKindsByProjectKey MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/context-kinds.
    Get context kinds
    """
    logger.info(f"Handling getContextKindsByProjectKey with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/context-kinds"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getContextKindsByProjectKey"] = handle_getContextKindsByProjectKey
async def handle_putContextKind(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the putContextKind MCP function.
    
    Makes an HTTP PUT request to /api/v2/projects/{projectKey}/context-kinds/{key}.
    Create or update context kind
    """
    logger.info(f"Handling putContextKind with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/context-kinds/{key}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {key}} with the value from params
    if "key" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: key"
        )
    path = path.replace("{key}}", str(params["key"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["putContextKind"] = handle_putContextKind
async def handle_getEnvironmentsByProject(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getEnvironmentsByProject MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments.
    List environments
    """
    logger.info(f"Handling getEnvironmentsByProject with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getEnvironmentsByProject"] = handle_getEnvironmentsByProject
async def handle_postEnvironment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postEnvironment MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/environments.
    Create environment
    """
    logger.info(f"Handling postEnvironment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postEnvironment"] = handle_postEnvironment
async def handle_getEnvironment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getEnvironment MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}.
    Get environment
    """
    logger.info(f"Handling getEnvironment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getEnvironment"] = handle_getEnvironment
async def handle_patchEnvironment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchEnvironment MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}/environments/{environmentKey}.
    Update environment
    """
    logger.info(f"Handling patchEnvironment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchEnvironment"] = handle_patchEnvironment
async def handle_deleteEnvironment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteEnvironment MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/environments/{environmentKey}.
    Delete environment
    """
    logger.info(f"Handling deleteEnvironment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteEnvironment"] = handle_deleteEnvironment
async def handle_resetEnvironmentSDKKey(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the resetEnvironmentSDKKey MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/environments/{environmentKey}/apiKey.
    Reset environment SDK key
    """
    logger.info(f"Handling resetEnvironmentSDKKey with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/apiKey"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expiry" in params:
        query_params["expiry"] = params["expiry"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["resetEnvironmentSDKKey"] = handle_resetEnvironmentSDKKey
async def handle_getContextAttributeNames(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getContextAttributeNames MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/context-attributes.
    Get context attribute names
    """
    logger.info(f"Handling getContextAttributeNames with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/context-attributes"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getContextAttributeNames"] = handle_getContextAttributeNames
async def handle_getContextAttributeValues(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getContextAttributeValues MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/context-attributes/{attributeName}.
    Get context attribute values
    """
    logger.info(f"Handling getContextAttributeValues with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/context-attributes/{attributeName}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {attributeName}} with the value from params
    if "attributeName" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: attributeName"
        )
    path = path.replace("{attributeName}}", str(params["attributeName"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getContextAttributeValues"] = handle_getContextAttributeValues
async def handle_searchContextInstances(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the searchContextInstances MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/environments/{environmentKey}/context-instances/search.
    Search for context instances
    """
    logger.info(f"Handling searchContextInstances with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/context-instances/search"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "continuationToken" in params:
        query_params["continuationToken"] = params["continuationToken"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "includeTotalCount" in params:
        query_params["includeTotalCount"] = params["includeTotalCount"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["searchContextInstances"] = handle_searchContextInstances
async def handle_getContextInstances(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getContextInstances MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/context-instances/{id}.
    Get context instances
    """
    logger.info(f"Handling getContextInstances with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/context-instances/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "continuationToken" in params:
        query_params["continuationToken"] = params["continuationToken"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "includeTotalCount" in params:
        query_params["includeTotalCount"] = params["includeTotalCount"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getContextInstances"] = handle_getContextInstances
async def handle_deleteContextInstances(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteContextInstances MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/environments/{environmentKey}/context-instances/{id}.
    Delete context instances
    """
    logger.info(f"Handling deleteContextInstances with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/context-instances/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteContextInstances"] = handle_deleteContextInstances
async def handle_searchContexts(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the searchContexts MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/environments/{environmentKey}/contexts/search.
    Search for contexts
    """
    logger.info(f"Handling searchContexts with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/contexts/search"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "continuationToken" in params:
        query_params["continuationToken"] = params["continuationToken"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "includeTotalCount" in params:
        query_params["includeTotalCount"] = params["includeTotalCount"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["searchContexts"] = handle_searchContexts
async def handle_putContextFlagSetting(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the putContextFlagSetting MCP function.
    
    Makes an HTTP PUT request to /api/v2/projects/{projectKey}/environments/{environmentKey}/contexts/{contextKind}/{contextKey}/flags/{featureFlagKey}.
    Update flag settings for context
    """
    logger.info(f"Handling putContextFlagSetting with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/contexts/{contextKind}/{contextKey}/flags/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {contextKind}} with the value from params
    if "contextKind" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: contextKind"
        )
    path = path.replace("{contextKind}}", str(params["contextKind"]))
    # Replace path parameter {contextKey}} with the value from params
    if "contextKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: contextKey"
        )
    path = path.replace("{contextKey}}", str(params["contextKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["putContextFlagSetting"] = handle_putContextFlagSetting
async def handle_getContexts(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getContexts MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/contexts/{kind}/{key}.
    Get contexts
    """
    logger.info(f"Handling getContexts with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/contexts/{kind}/{key}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {kind}} with the value from params
    if "kind" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: kind"
        )
    path = path.replace("{kind}}", str(params["kind"]))
    # Replace path parameter {key}} with the value from params
    if "key" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: key"
        )
    path = path.replace("{key}}", str(params["key"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "continuationToken" in params:
        query_params["continuationToken"] = params["continuationToken"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "includeTotalCount" in params:
        query_params["includeTotalCount"] = params["includeTotalCount"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getContexts"] = handle_getContexts
async def handle_getExperiments(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExperiments MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/experiments.
    Get experiments
    """
    logger.info(f"Handling getExperiments with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    if "lifecycleState" in params:
        query_params["lifecycleState"] = params["lifecycleState"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExperiments"] = handle_getExperiments
async def handle_createExperiment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createExperiment MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/environments/{environmentKey}/experiments.
    Create experiment
    """
    logger.info(f"Handling createExperiment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createExperiment"] = handle_createExperiment
async def handle_getExperiment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExperiment MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}.
    Get experiment
    """
    logger.info(f"Handling getExperiment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {experimentKey}} with the value from params
    if "experimentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: experimentKey"
        )
    path = path.replace("{experimentKey}}", str(params["experimentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExperiment"] = handle_getExperiment
async def handle_patchExperiment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchExperiment MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}.
    Patch experiment
    """
    logger.info(f"Handling patchExperiment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {experimentKey}} with the value from params
    if "experimentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: experimentKey"
        )
    path = path.replace("{experimentKey}}", str(params["experimentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchExperiment"] = handle_patchExperiment
async def handle_createIteration(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createIteration MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/iterations.
    Create iteration
    """
    logger.info(f"Handling createIteration with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/iterations"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {experimentKey}} with the value from params
    if "experimentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: experimentKey"
        )
    path = path.replace("{experimentKey}}", str(params["experimentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createIteration"] = handle_createIteration
async def handle_getExperimentResultsForMetricGroup(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExperimentResultsForMetricGroup MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/metric-groups/{metricGroupKey}/results.
    Get experiment results for metric group (Deprecated)
    """
    logger.info(f"Handling getExperimentResultsForMetricGroup with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/metric-groups/{metricGroupKey}/results"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {experimentKey}} with the value from params
    if "experimentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: experimentKey"
        )
    path = path.replace("{experimentKey}}", str(params["experimentKey"]))
    # Replace path parameter {metricGroupKey}} with the value from params
    if "metricGroupKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: metricGroupKey"
        )
    path = path.replace("{metricGroupKey}}", str(params["metricGroupKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "iterationId" in params:
        query_params["iterationId"] = params["iterationId"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExperimentResultsForMetricGroup"] = handle_getExperimentResultsForMetricGroup
async def handle_getExperimentResults(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExperimentResults MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/metrics/{metricKey}/results.
    Get experiment results (Deprecated)
    """
    logger.info(f"Handling getExperimentResults with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/metrics/{metricKey}/results"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {experimentKey}} with the value from params
    if "experimentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: experimentKey"
        )
    path = path.replace("{experimentKey}}", str(params["experimentKey"]))
    # Replace path parameter {metricKey}} with the value from params
    if "metricKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: metricKey"
        )
    path = path.replace("{metricKey}}", str(params["metricKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "iterationId" in params:
        query_params["iterationId"] = params["iterationId"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExperimentResults"] = handle_getExperimentResults
async def handle_evaluateContextInstance(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the evaluateContextInstance MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/environments/{environmentKey}/flags/evaluate.
    Evaluate flags for context instance
    """
    logger.info(f"Handling evaluateContextInstance with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/flags/evaluate"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["evaluateContextInstance"] = handle_evaluateContextInstance
async def handle_getFollowersByProjEnv(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFollowersByProjEnv MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/followers.
    Get followers of all flags in a given project and environment
    """
    logger.info(f"Handling getFollowersByProjEnv with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/followers"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFollowersByProjEnv"] = handle_getFollowersByProjEnv
async def handle_getAllHoldouts(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAllHoldouts MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts.
    Get all holdouts
    """
    logger.info(f"Handling getAllHoldouts with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAllHoldouts"] = handle_getAllHoldouts
async def handle_postHoldout(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postHoldout MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts.
    Create holdout
    """
    logger.info(f"Handling postHoldout with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postHoldout"] = handle_postHoldout
async def handle_getHoldoutById(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getHoldoutById MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts/id/{holdoutId}.
    Get Holdout by Id
    """
    logger.info(f"Handling getHoldoutById with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts/id/{holdoutId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {holdoutId}} with the value from params
    if "holdoutId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: holdoutId"
        )
    path = path.replace("{holdoutId}}", str(params["holdoutId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getHoldoutById"] = handle_getHoldoutById
async def handle_getHoldout(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getHoldout MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts/{holdoutKey}.
    Get holdout
    """
    logger.info(f"Handling getHoldout with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts/{holdoutKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {holdoutKey}} with the value from params
    if "holdoutKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: holdoutKey"
        )
    path = path.replace("{holdoutKey}}", str(params["holdoutKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getHoldout"] = handle_getHoldout
async def handle_patchHoldout(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchHoldout MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts/{holdoutKey}.
    Patch holdout
    """
    logger.info(f"Handling patchHoldout with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts/{holdoutKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {holdoutKey}} with the value from params
    if "holdoutKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: holdoutKey"
        )
    path = path.replace("{holdoutKey}}", str(params["holdoutKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchHoldout"] = handle_patchHoldout
async def handle_resetEnvironmentMobileKey(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the resetEnvironmentMobileKey MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/environments/{environmentKey}/mobileKey.
    Reset environment mobile SDK key
    """
    logger.info(f"Handling resetEnvironmentMobileKey with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/mobileKey"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["resetEnvironmentMobileKey"] = handle_resetEnvironmentMobileKey
async def handle_getContextInstanceSegmentsMembershipByEnv(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getContextInstanceSegmentsMembershipByEnv MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/environments/{environmentKey}/segments/evaluate.
    List segment memberships for context instance
    """
    logger.info(f"Handling getContextInstanceSegmentsMembershipByEnv with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/segments/evaluate"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getContextInstanceSegmentsMembershipByEnv"] = handle_getContextInstanceSegmentsMembershipByEnv
async def handle_getExperimentationSettings(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExperimentationSettings MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/experimentation-settings.
    Get experimentation settings
    """
    logger.info(f"Handling getExperimentationSettings with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/experimentation-settings"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExperimentationSettings"] = handle_getExperimentationSettings
async def handle_putExperimentationSettings(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the putExperimentationSettings MCP function.
    
    Makes an HTTP PUT request to /api/v2/projects/{projectKey}/experimentation-settings.
    Update experimentation settings
    """
    logger.info(f"Handling putExperimentationSettings with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/experimentation-settings"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["putExperimentationSettings"] = handle_putExperimentationSettings
async def handle_getFlagDefaultsByProject(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFlagDefaultsByProject MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/flag-defaults.
    Get flag defaults for project
    """
    logger.info(f"Handling getFlagDefaultsByProject with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flag-defaults"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFlagDefaultsByProject"] = handle_getFlagDefaultsByProject
async def handle_patchFlagDefaultsByProject(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchFlagDefaultsByProject MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}/flag-defaults.
    Update flag default for project
    """
    logger.info(f"Handling patchFlagDefaultsByProject with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flag-defaults"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchFlagDefaultsByProject"] = handle_patchFlagDefaultsByProject
async def handle_putFlagDefaultsByProject(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the putFlagDefaultsByProject MCP function.
    
    Makes an HTTP PUT request to /api/v2/projects/{projectKey}/flag-defaults.
    Create or update flag defaults for project
    """
    logger.info(f"Handling putFlagDefaultsByProject with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flag-defaults"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["putFlagDefaultsByProject"] = handle_putFlagDefaultsByProject
async def handle_getApprovalsForFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getApprovalsForFlag MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests.
    List approval requests for a flag
    """
    logger.info(f"Handling getApprovalsForFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getApprovalsForFlag"] = handle_getApprovalsForFlag
async def handle_postApprovalRequestForFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postApprovalRequestForFlag MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests.
    Create approval request for a flag
    """
    logger.info(f"Handling postApprovalRequestForFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postApprovalRequestForFlag"] = handle_postApprovalRequestForFlag
async def handle_postFlagCopyConfigApprovalRequest(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postFlagCopyConfigApprovalRequest MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests-flag-copy.
    Create approval request to copy flag configurations across environments
    """
    logger.info(f"Handling postFlagCopyConfigApprovalRequest with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests-flag-copy"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postFlagCopyConfigApprovalRequest"] = handle_postFlagCopyConfigApprovalRequest
async def handle_getApprovalForFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getApprovalForFlag MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}.
    Get approval request for a flag
    """
    logger.info(f"Handling getApprovalForFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getApprovalForFlag"] = handle_getApprovalForFlag
async def handle_patchFlagConfigApprovalRequest(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchFlagConfigApprovalRequest MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}.
    Update flag approval request
    """
    logger.info(f"Handling patchFlagConfigApprovalRequest with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchFlagConfigApprovalRequest"] = handle_patchFlagConfigApprovalRequest
async def handle_deleteApprovalRequestForFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteApprovalRequestForFlag MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}.
    Delete approval request for a flag
    """
    logger.info(f"Handling deleteApprovalRequestForFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteApprovalRequestForFlag"] = handle_deleteApprovalRequestForFlag
async def handle_postApprovalRequestApplyForFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postApprovalRequestApplyForFlag MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}/apply.
    Apply approval request for a flag
    """
    logger.info(f"Handling postApprovalRequestApplyForFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}/apply"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postApprovalRequestApplyForFlag"] = handle_postApprovalRequestApplyForFlag
async def handle_postApprovalRequestReviewForFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postApprovalRequestReviewForFlag MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}/reviews.
    Review approval request for a flag
    """
    logger.info(f"Handling postApprovalRequestReviewForFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}/reviews"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postApprovalRequestReviewForFlag"] = handle_postApprovalRequestReviewForFlag
async def handle_getFlagFollowers(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFlagFollowers MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers.
    Get followers of a flag in a project and environment
    """
    logger.info(f"Handling getFlagFollowers with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFlagFollowers"] = handle_getFlagFollowers
async def handle_putFlagFollower(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the putFlagFollower MCP function.
    
    Makes an HTTP PUT request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers/{memberId}.
    Add a member as a follower of a flag in a project and environment
    """
    logger.info(f"Handling putFlagFollower with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers/{memberId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {memberId}} with the value from params
    if "memberId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: memberId"
        )
    path = path.replace("{memberId}}", str(params["memberId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["putFlagFollower"] = handle_putFlagFollower
async def handle_deleteFlagFollower(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteFlagFollower MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers/{memberId}.
    Remove a member as a follower of a flag in a project and environment
    """
    logger.info(f"Handling deleteFlagFollower with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers/{memberId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {memberId}} with the value from params
    if "memberId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: memberId"
        )
    path = path.replace("{memberId}}", str(params["memberId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteFlagFollower"] = handle_deleteFlagFollower
async def handle_getFlagConfigScheduledChanges(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFlagConfigScheduledChanges MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes.
    List scheduled changes
    """
    logger.info(f"Handling getFlagConfigScheduledChanges with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFlagConfigScheduledChanges"] = handle_getFlagConfigScheduledChanges
async def handle_postFlagConfigScheduledChanges(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postFlagConfigScheduledChanges MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes.
    Create scheduled changes workflow
    """
    logger.info(f"Handling postFlagConfigScheduledChanges with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "ignoreConflicts" in params:
        query_params["ignoreConflicts"] = params["ignoreConflicts"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postFlagConfigScheduledChanges"] = handle_postFlagConfigScheduledChanges
async def handle_getFeatureFlagScheduledChange(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFeatureFlagScheduledChange MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}.
    Get a scheduled change
    """
    logger.info(f"Handling getFeatureFlagScheduledChange with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFeatureFlagScheduledChange"] = handle_getFeatureFlagScheduledChange
async def handle_patchFlagConfigScheduledChange(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchFlagConfigScheduledChange MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}.
    Update scheduled changes workflow
    """
    logger.info(f"Handling patchFlagConfigScheduledChange with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "ignoreConflicts" in params:
        query_params["ignoreConflicts"] = params["ignoreConflicts"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchFlagConfigScheduledChange"] = handle_patchFlagConfigScheduledChange
async def handle_deleteFlagConfigScheduledChanges(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteFlagConfigScheduledChanges MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}.
    Delete scheduled changes workflow
    """
    logger.info(f"Handling deleteFlagConfigScheduledChanges with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteFlagConfigScheduledChanges"] = handle_deleteFlagConfigScheduledChanges
async def handle_getWorkflows(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getWorkflows MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows.
    Get workflows
    """
    logger.info(f"Handling getWorkflows with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "status" in params:
        query_params["status"] = params["status"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getWorkflows"] = handle_getWorkflows
async def handle_postWorkflow(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postWorkflow MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows.
    Create workflow
    """
    logger.info(f"Handling postWorkflow with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "templateKey" in params:
        query_params["templateKey"] = params["templateKey"]
    if "dryRun" in params:
        query_params["dryRun"] = params["dryRun"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postWorkflow"] = handle_postWorkflow
async def handle_getCustomWorkflow(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getCustomWorkflow MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows/{workflowId}.
    Get custom workflow
    """
    logger.info(f"Handling getCustomWorkflow with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows/{workflowId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {workflowId}} with the value from params
    if "workflowId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: workflowId"
        )
    path = path.replace("{workflowId}}", str(params["workflowId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getCustomWorkflow"] = handle_getCustomWorkflow
async def handle_deleteWorkflow(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteWorkflow MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows/{workflowId}.
    Delete workflow
    """
    logger.info(f"Handling deleteWorkflow with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows/{workflowId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {workflowId}} with the value from params
    if "workflowId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: workflowId"
        )
    path = path.replace("{workflowId}}", str(params["workflowId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteWorkflow"] = handle_deleteWorkflow
async def handle_postMigrationSafetyIssues(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postMigrationSafetyIssues MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/flags/{flagKey}/environments/{environmentKey}/migration-safety-issues.
    Get migration safety issues
    """
    logger.info(f"Handling postMigrationSafetyIssues with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{flagKey}/environments/{environmentKey}/migration-safety-issues"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {flagKey}} with the value from params
    if "flagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: flagKey"
        )
    path = path.replace("{flagKey}}", str(params["flagKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postMigrationSafetyIssues"] = handle_postMigrationSafetyIssues
async def handle_createReleaseForFlag(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createReleaseForFlag MCP function.
    
    Makes an HTTP PUT request to /api/v2/projects/{projectKey}/flags/{flagKey}/release.
    Create a new release for flag
    """
    logger.info(f"Handling createReleaseForFlag with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{flagKey}/release"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {flagKey}} with the value from params
    if "flagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: flagKey"
        )
    path = path.replace("{flagKey}}", str(params["flagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createReleaseForFlag"] = handle_createReleaseForFlag
async def handle_updatePhaseStatus(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the updatePhaseStatus MCP function.
    
    Makes an HTTP PUT request to /api/v2/projects/{projectKey}/flags/{flagKey}/release/phases/{phaseId}.
    Update phase status for release
    """
    logger.info(f"Handling updatePhaseStatus with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/flags/{flagKey}/release/phases/{phaseId}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {flagKey}} with the value from params
    if "flagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: flagKey"
        )
    path = path.replace("{flagKey}}", str(params["flagKey"]))
    # Replace path parameter {phaseId}} with the value from params
    if "phaseId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: phaseId"
        )
    path = path.replace("{phaseId}}", str(params["phaseId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["updatePhaseStatus"] = handle_updatePhaseStatus
async def handle_getLayers(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getLayers MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/layers.
    Get layers
    """
    logger.info(f"Handling getLayers with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/layers"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "filter" in params:
        query_params["filter"] = params["filter"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getLayers"] = handle_getLayers
async def handle_createLayer(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createLayer MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/layers.
    Create layer
    """
    logger.info(f"Handling createLayer with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/layers"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createLayer"] = handle_createLayer
async def handle_updateLayer(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the updateLayer MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}/layers/{layerKey}.
    Update layer
    """
    logger.info(f"Handling updateLayer with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/layers/{layerKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {layerKey}} with the value from params
    if "layerKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: layerKey"
        )
    path = path.replace("{layerKey}}", str(params["layerKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["updateLayer"] = handle_updateLayer
async def handle_getMetricGroups(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getMetricGroups MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/metric-groups.
    List metric groups
    """
    logger.info(f"Handling getMetricGroups with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/metric-groups"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getMetricGroups"] = handle_getMetricGroups
async def handle_createMetricGroup(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createMetricGroup MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/metric-groups.
    Create metric group
    """
    logger.info(f"Handling createMetricGroup with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/metric-groups"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createMetricGroup"] = handle_createMetricGroup
async def handle_getMetricGroup(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getMetricGroup MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/metric-groups/{metricGroupKey}.
    Get metric group
    """
    logger.info(f"Handling getMetricGroup with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/metric-groups/{metricGroupKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {metricGroupKey}} with the value from params
    if "metricGroupKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: metricGroupKey"
        )
    path = path.replace("{metricGroupKey}}", str(params["metricGroupKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getMetricGroup"] = handle_getMetricGroup
async def handle_patchMetricGroup(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchMetricGroup MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}/metric-groups/{metricGroupKey}.
    Patch metric group
    """
    logger.info(f"Handling patchMetricGroup with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/metric-groups/{metricGroupKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {metricGroupKey}} with the value from params
    if "metricGroupKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: metricGroupKey"
        )
    path = path.replace("{metricGroupKey}}", str(params["metricGroupKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchMetricGroup"] = handle_patchMetricGroup
async def handle_deleteMetricGroup(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteMetricGroup MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/metric-groups/{metricGroupKey}.
    Delete metric group
    """
    logger.info(f"Handling deleteMetricGroup with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/metric-groups/{metricGroupKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {metricGroupKey}} with the value from params
    if "metricGroupKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: metricGroupKey"
        )
    path = path.replace("{metricGroupKey}}", str(params["metricGroupKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteMetricGroup"] = handle_deleteMetricGroup
async def handle_getAllReleasePipelines(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAllReleasePipelines MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/release-pipelines.
    Get all release pipelines
    """
    logger.info(f"Handling getAllReleasePipelines with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/release-pipelines"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAllReleasePipelines"] = handle_getAllReleasePipelines
async def handle_postReleasePipeline(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postReleasePipeline MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/release-pipelines.
    Create a release pipeline
    """
    logger.info(f"Handling postReleasePipeline with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/release-pipelines"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postReleasePipeline"] = handle_postReleasePipeline
async def handle_getReleasePipelineByKey(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getReleasePipelineByKey MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}.
    Get release pipeline by key
    """
    logger.info(f"Handling getReleasePipelineByKey with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {pipelineKey}} with the value from params
    if "pipelineKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: pipelineKey"
        )
    path = path.replace("{pipelineKey}}", str(params["pipelineKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getReleasePipelineByKey"] = handle_getReleasePipelineByKey
async def handle_putReleasePipeline(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the putReleasePipeline MCP function.
    
    Makes an HTTP PUT request to /api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}.
    Update a release pipeline
    """
    logger.info(f"Handling putReleasePipeline with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {pipelineKey}} with the value from params
    if "pipelineKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: pipelineKey"
        )
    path = path.replace("{pipelineKey}}", str(params["pipelineKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["putReleasePipeline"] = handle_putReleasePipeline
async def handle_deleteReleasePipeline(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteReleasePipeline MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}.
    Delete release pipeline
    """
    logger.info(f"Handling deleteReleasePipeline with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {pipelineKey}} with the value from params
    if "pipelineKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: pipelineKey"
        )
    path = path.replace("{pipelineKey}}", str(params["pipelineKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteReleasePipeline"] = handle_deleteReleasePipeline
async def handle_getAllReleaseProgressionsForReleasePipeline(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAllReleaseProgressionsForReleasePipeline MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}/releases.
    Get release progressions for release pipeline
    """
    logger.info(f"Handling getAllReleaseProgressionsForReleasePipeline with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}/releases"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {pipelineKey}} with the value from params
    if "pipelineKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: pipelineKey"
        )
    path = path.replace("{pipelineKey}}", str(params["pipelineKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAllReleaseProgressionsForReleasePipeline"] = handle_getAllReleaseProgressionsForReleasePipeline
async def handle_getIps(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getIps MCP function.
    
    Makes an HTTP GET request to /api/v2/public-ip-list.
    Gets the public IP list
    """
    logger.info(f"Handling getIps with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/public-ip-list"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getIps"] = handle_getIps
async def handle_getCustomRoles(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getCustomRoles MCP function.
    
    Makes an HTTP GET request to /api/v2/roles.
    List custom roles
    """
    logger.info(f"Handling getCustomRoles with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/roles"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getCustomRoles"] = handle_getCustomRoles
async def handle_postCustomRole(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postCustomRole MCP function.
    
    Makes an HTTP POST request to /api/v2/roles.
    Create custom role
    """
    logger.info(f"Handling postCustomRole with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/roles"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postCustomRole"] = handle_postCustomRole
async def handle_getCustomRole(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getCustomRole MCP function.
    
    Makes an HTTP GET request to /api/v2/roles/{customRoleKey}.
    Get custom role
    """
    logger.info(f"Handling getCustomRole with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/roles/{customRoleKey}"
    # Replace path parameter {customRoleKey}} with the value from params
    if "customRoleKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: customRoleKey"
        )
    path = path.replace("{customRoleKey}}", str(params["customRoleKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getCustomRole"] = handle_getCustomRole
async def handle_patchCustomRole(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchCustomRole MCP function.
    
    Makes an HTTP PATCH request to /api/v2/roles/{customRoleKey}.
    Update custom role
    """
    logger.info(f"Handling patchCustomRole with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/roles/{customRoleKey}"
    # Replace path parameter {customRoleKey}} with the value from params
    if "customRoleKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: customRoleKey"
        )
    path = path.replace("{customRoleKey}}", str(params["customRoleKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchCustomRole"] = handle_patchCustomRole
async def handle_deleteCustomRole(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteCustomRole MCP function.
    
    Makes an HTTP DELETE request to /api/v2/roles/{customRoleKey}.
    Delete custom role
    """
    logger.info(f"Handling deleteCustomRole with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/roles/{customRoleKey}"
    # Replace path parameter {customRoleKey}} with the value from params
    if "customRoleKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: customRoleKey"
        )
    path = path.replace("{customRoleKey}}", str(params["customRoleKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteCustomRole"] = handle_deleteCustomRole
async def handle_getSegments(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getSegments MCP function.
    
    Makes an HTTP GET request to /api/v2/segments/{projectKey}/{environmentKey}.
    List segments
    """
    logger.info(f"Handling getSegments with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getSegments"] = handle_getSegments
async def handle_postSegment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postSegment MCP function.
    
    Makes an HTTP POST request to /api/v2/segments/{projectKey}/{environmentKey}.
    Create segment
    """
    logger.info(f"Handling postSegment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postSegment"] = handle_postSegment
async def handle_getSegment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getSegment MCP function.
    
    Makes an HTTP GET request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}.
    Get segment
    """
    logger.info(f"Handling getSegment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getSegment"] = handle_getSegment
async def handle_patchSegment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchSegment MCP function.
    
    Makes an HTTP PATCH request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}.
    Patch segment
    """
    logger.info(f"Handling patchSegment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchSegment"] = handle_patchSegment
async def handle_deleteSegment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteSegment MCP function.
    
    Makes an HTTP DELETE request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}.
    Delete segment
    """
    logger.info(f"Handling deleteSegment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteSegment"] = handle_deleteSegment
async def handle_updateBigSegmentContextTargets(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the updateBigSegmentContextTargets MCP function.
    
    Makes an HTTP POST request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/contexts.
    Update context targets on a big segment
    """
    logger.info(f"Handling updateBigSegmentContextTargets with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/contexts"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["updateBigSegmentContextTargets"] = handle_updateBigSegmentContextTargets
async def handle_getSegmentMembershipForContext(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getSegmentMembershipForContext MCP function.
    
    Makes an HTTP GET request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/contexts/{contextKey}.
    Get big segment membership for context
    """
    logger.info(f"Handling getSegmentMembershipForContext with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/contexts/{contextKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    # Replace path parameter {contextKey}} with the value from params
    if "contextKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: contextKey"
        )
    path = path.replace("{contextKey}}", str(params["contextKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getSegmentMembershipForContext"] = handle_getSegmentMembershipForContext
async def handle_createBigSegmentExport(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createBigSegmentExport MCP function.
    
    Makes an HTTP POST request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/exports.
    Create big segment export
    """
    logger.info(f"Handling createBigSegmentExport with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/exports"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createBigSegmentExport"] = handle_createBigSegmentExport
async def handle_getBigSegmentExport(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getBigSegmentExport MCP function.
    
    Makes an HTTP GET request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/exports/{exportID}.
    Get big segment export
    """
    logger.info(f"Handling getBigSegmentExport with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/exports/{exportID}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    # Replace path parameter {exportID}} with the value from params
    if "exportID" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: exportID"
        )
    path = path.replace("{exportID}}", str(params["exportID"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getBigSegmentExport"] = handle_getBigSegmentExport
async def handle_createBigSegmentImport(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createBigSegmentImport MCP function.
    
    Makes an HTTP POST request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/imports.
    Create big segment import
    """
    logger.info(f"Handling createBigSegmentImport with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/imports"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createBigSegmentImport"] = handle_createBigSegmentImport
async def handle_getBigSegmentImport(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getBigSegmentImport MCP function.
    
    Makes an HTTP GET request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/imports/{importID}.
    Get big segment import
    """
    logger.info(f"Handling getBigSegmentImport with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/imports/{importID}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    # Replace path parameter {importID}} with the value from params
    if "importID" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: importID"
        )
    path = path.replace("{importID}}", str(params["importID"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getBigSegmentImport"] = handle_getBigSegmentImport
async def handle_updateBigSegmentTargets(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the updateBigSegmentTargets MCP function.
    
    Makes an HTTP POST request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/users.
    Update user context targets on a big segment
    """
    logger.info(f"Handling updateBigSegmentTargets with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/users"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["updateBigSegmentTargets"] = handle_updateBigSegmentTargets
async def handle_getSegmentMembershipForUser(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getSegmentMembershipForUser MCP function.
    
    Makes an HTTP GET request to /api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/users/{userKey}.
    Get big segment membership for user
    """
    logger.info(f"Handling getSegmentMembershipForUser with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/users/{userKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    # Replace path parameter {userKey}} with the value from params
    if "userKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: userKey"
        )
    path = path.replace("{userKey}}", str(params["userKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getSegmentMembershipForUser"] = handle_getSegmentMembershipForUser
async def handle_getExpiringTargetsForSegment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExpiringTargetsForSegment MCP function.
    
    Makes an HTTP GET request to /api/v2/segments/{projectKey}/{segmentKey}/expiring-targets/{environmentKey}.
    Get expiring targets for segment
    """
    logger.info(f"Handling getExpiringTargetsForSegment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{segmentKey}/expiring-targets/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExpiringTargetsForSegment"] = handle_getExpiringTargetsForSegment
async def handle_patchExpiringTargetsForSegment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchExpiringTargetsForSegment MCP function.
    
    Makes an HTTP PATCH request to /api/v2/segments/{projectKey}/{segmentKey}/expiring-targets/{environmentKey}.
    Update expiring targets for segment
    """
    logger.info(f"Handling patchExpiringTargetsForSegment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{segmentKey}/expiring-targets/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchExpiringTargetsForSegment"] = handle_patchExpiringTargetsForSegment
async def handle_getExpiringUserTargetsForSegment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExpiringUserTargetsForSegment MCP function.
    
    Makes an HTTP GET request to /api/v2/segments/{projectKey}/{segmentKey}/expiring-user-targets/{environmentKey}.
    Get expiring user targets for segment
    """
    logger.info(f"Handling getExpiringUserTargetsForSegment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{segmentKey}/expiring-user-targets/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExpiringUserTargetsForSegment"] = handle_getExpiringUserTargetsForSegment
async def handle_patchExpiringUserTargetsForSegment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchExpiringUserTargetsForSegment MCP function.
    
    Makes an HTTP PATCH request to /api/v2/segments/{projectKey}/{segmentKey}/expiring-user-targets/{environmentKey}.
    Update expiring user targets for segment
    """
    logger.info(f"Handling patchExpiringUserTargetsForSegment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/segments/{projectKey}/{segmentKey}/expiring-user-targets/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {segmentKey}} with the value from params
    if "segmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: segmentKey"
        )
    path = path.replace("{segmentKey}}", str(params["segmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchExpiringUserTargetsForSegment"] = handle_patchExpiringUserTargetsForSegment
async def handle_getTeams(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getTeams MCP function.
    
    Makes an HTTP GET request to /api/v2/teams.
    List teams
    """
    logger.info(f"Handling getTeams with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/teams"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getTeams"] = handle_getTeams
async def handle_postTeam(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postTeam MCP function.
    
    Makes an HTTP POST request to /api/v2/teams.
    Create team
    """
    logger.info(f"Handling postTeam with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/teams"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postTeam"] = handle_postTeam
async def handle_patchTeams(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchTeams MCP function.
    
    Makes an HTTP PATCH request to /api/v2/teams.
    Update teams
    """
    logger.info(f"Handling patchTeams with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/teams"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchTeams"] = handle_patchTeams
async def handle_getTeam(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getTeam MCP function.
    
    Makes an HTTP GET request to /api/v2/teams/{teamKey}.
    Get team
    """
    logger.info(f"Handling getTeam with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/teams/{teamKey}"
    # Replace path parameter {teamKey}} with the value from params
    if "teamKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: teamKey"
        )
    path = path.replace("{teamKey}}", str(params["teamKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getTeam"] = handle_getTeam
async def handle_patchTeam(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchTeam MCP function.
    
    Makes an HTTP PATCH request to /api/v2/teams/{teamKey}.
    Update team
    """
    logger.info(f"Handling patchTeam with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/teams/{teamKey}"
    # Replace path parameter {teamKey}} with the value from params
    if "teamKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: teamKey"
        )
    path = path.replace("{teamKey}}", str(params["teamKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchTeam"] = handle_patchTeam
async def handle_deleteTeam(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteTeam MCP function.
    
    Makes an HTTP DELETE request to /api/v2/teams/{teamKey}.
    Delete team
    """
    logger.info(f"Handling deleteTeam with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/teams/{teamKey}"
    # Replace path parameter {teamKey}} with the value from params
    if "teamKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: teamKey"
        )
    path = path.replace("{teamKey}}", str(params["teamKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteTeam"] = handle_deleteTeam
async def handle_getTeamMaintainers(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getTeamMaintainers MCP function.
    
    Makes an HTTP GET request to /api/v2/teams/{teamKey}/maintainers.
    Get team maintainers
    """
    logger.info(f"Handling getTeamMaintainers with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/teams/{teamKey}/maintainers"
    # Replace path parameter {teamKey}} with the value from params
    if "teamKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: teamKey"
        )
    path = path.replace("{teamKey}}", str(params["teamKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getTeamMaintainers"] = handle_getTeamMaintainers
async def handle_postTeamMembers(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postTeamMembers MCP function.
    
    Makes an HTTP POST request to /api/v2/teams/{teamKey}/members.
    Add multiple members to team
    """
    logger.info(f"Handling postTeamMembers with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/teams/{teamKey}/members"
    # Replace path parameter {teamKey}} with the value from params
    if "teamKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: teamKey"
        )
    path = path.replace("{teamKey}}", str(params["teamKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postTeamMembers"] = handle_postTeamMembers
async def handle_getTeamRoles(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getTeamRoles MCP function.
    
    Makes an HTTP GET request to /api/v2/teams/{teamKey}/roles.
    Get team custom roles
    """
    logger.info(f"Handling getTeamRoles with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/teams/{teamKey}/roles"
    # Replace path parameter {teamKey}} with the value from params
    if "teamKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: teamKey"
        )
    path = path.replace("{teamKey}}", str(params["teamKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getTeamRoles"] = handle_getTeamRoles
async def handle_getWorkflowTemplates(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getWorkflowTemplates MCP function.
    
    Makes an HTTP GET request to /api/v2/templates.
    Get workflow templates
    """
    logger.info(f"Handling getWorkflowTemplates with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/templates"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "summary" in params:
        query_params["summary"] = params["summary"]
    if "search" in params:
        query_params["search"] = params["search"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getWorkflowTemplates"] = handle_getWorkflowTemplates
async def handle_createWorkflowTemplate(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createWorkflowTemplate MCP function.
    
    Makes an HTTP POST request to /api/v2/templates.
    Create workflow template
    """
    logger.info(f"Handling createWorkflowTemplate with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/templates"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createWorkflowTemplate"] = handle_createWorkflowTemplate
async def handle_deleteWorkflowTemplate(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteWorkflowTemplate MCP function.
    
    Makes an HTTP DELETE request to /api/v2/templates/{templateKey}.
    Delete workflow template
    """
    logger.info(f"Handling deleteWorkflowTemplate with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/templates/{templateKey}"
    # Replace path parameter {templateKey}} with the value from params
    if "templateKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: templateKey"
        )
    path = path.replace("{templateKey}}", str(params["templateKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteWorkflowTemplate"] = handle_deleteWorkflowTemplate
async def handle_getTokens(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getTokens MCP function.
    
    Makes an HTTP GET request to /api/v2/tokens.
    List access tokens
    """
    logger.info(f"Handling getTokens with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/tokens"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "showAll" in params:
        query_params["showAll"] = params["showAll"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getTokens"] = handle_getTokens
async def handle_postToken(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postToken MCP function.
    
    Makes an HTTP POST request to /api/v2/tokens.
    Create access token
    """
    logger.info(f"Handling postToken with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/tokens"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postToken"] = handle_postToken
async def handle_getToken(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getToken MCP function.
    
    Makes an HTTP GET request to /api/v2/tokens/{id}.
    Get access token
    """
    logger.info(f"Handling getToken with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/tokens/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getToken"] = handle_getToken
async def handle_patchToken(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchToken MCP function.
    
    Makes an HTTP PATCH request to /api/v2/tokens/{id}.
    Patch access token
    """
    logger.info(f"Handling patchToken with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/tokens/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchToken"] = handle_patchToken
async def handle_deleteToken(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteToken MCP function.
    
    Makes an HTTP DELETE request to /api/v2/tokens/{id}.
    Delete access token
    """
    logger.info(f"Handling deleteToken with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/tokens/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteToken"] = handle_deleteToken
async def handle_resetToken(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the resetToken MCP function.
    
    Makes an HTTP POST request to /api/v2/tokens/{id}/reset.
    Reset access token
    """
    logger.info(f"Handling resetToken with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/tokens/{id}/reset"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expiry" in params:
        query_params["expiry"] = params["expiry"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["resetToken"] = handle_resetToken
async def handle_getDataExportEventsUsage(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getDataExportEventsUsage MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/data-export-events.
    Get data export events usage
    """
    logger.info(f"Handling getDataExportEventsUsage with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/data-export-events"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getDataExportEventsUsage"] = handle_getDataExportEventsUsage
async def handle_getEvaluationsUsage(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getEvaluationsUsage MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/evaluations/{projectKey}/{environmentKey}/{featureFlagKey}.
    Get evaluations usage
    """
    logger.info(f"Handling getEvaluationsUsage with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/evaluations/{projectKey}/{environmentKey}/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "tz" in params:
        query_params["tz"] = params["tz"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getEvaluationsUsage"] = handle_getEvaluationsUsage
async def handle_getEventsUsage(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getEventsUsage MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/events/{type}.
    Get events usage
    """
    logger.info(f"Handling getEventsUsage with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/events/{type}"
    # Replace path parameter {type}} with the value from params
    if "type" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: type"
        )
    path = path.replace("{type}}", str(params["type"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getEventsUsage"] = handle_getEventsUsage
async def handle_getExperimentationKeysUsage(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExperimentationKeysUsage MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/experimentation-keys.
    Get experimentation keys usage
    """
    logger.info(f"Handling getExperimentationKeysUsage with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/experimentation-keys"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExperimentationKeysUsage"] = handle_getExperimentationKeysUsage
async def handle_getExperimentationUnitsUsage(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExperimentationUnitsUsage MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/experimentation-units.
    Get experimentation units usage
    """
    logger.info(f"Handling getExperimentationUnitsUsage with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/experimentation-units"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExperimentationUnitsUsage"] = handle_getExperimentationUnitsUsage
async def handle_getMauUsage(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getMauUsage MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/mau.
    Get MAU usage
    """
    logger.info(f"Handling getMauUsage with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/mau"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "project" in params:
        query_params["project"] = params["project"]
    if "environment" in params:
        query_params["environment"] = params["environment"]
    if "sdktype" in params:
        query_params["sdktype"] = params["sdktype"]
    if "sdk" in params:
        query_params["sdk"] = params["sdk"]
    if "anonymous" in params:
        query_params["anonymous"] = params["anonymous"]
    if "groupby" in params:
        query_params["groupby"] = params["groupby"]
    if "aggregationType" in params:
        query_params["aggregationType"] = params["aggregationType"]
    if "contextKind" in params:
        query_params["contextKind"] = params["contextKind"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getMauUsage"] = handle_getMauUsage
async def handle_getMauUsageByCategory(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getMauUsageByCategory MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/mau/bycategory.
    Get MAU usage by category
    """
    logger.info(f"Handling getMauUsageByCategory with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/mau/bycategory"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getMauUsageByCategory"] = handle_getMauUsageByCategory
async def handle_getMauSdksByType(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getMauSdksByType MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/mau/sdks.
    Get MAU SDKs by type
    """
    logger.info(f"Handling getMauSdksByType with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/mau/sdks"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "sdktype" in params:
        query_params["sdktype"] = params["sdktype"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getMauSdksByType"] = handle_getMauSdksByType
async def handle_getServiceConnectionUsage(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getServiceConnectionUsage MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/service-connections.
    Get service connection usage
    """
    logger.info(f"Handling getServiceConnectionUsage with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/service-connections"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getServiceConnectionUsage"] = handle_getServiceConnectionUsage
async def handle_getStreamUsage(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getStreamUsage MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/streams/{source}.
    Get stream usage
    """
    logger.info(f"Handling getStreamUsage with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/streams/{source}"
    # Replace path parameter {source}} with the value from params
    if "source" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: source"
        )
    path = path.replace("{source}}", str(params["source"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "tz" in params:
        query_params["tz"] = params["tz"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getStreamUsage"] = handle_getStreamUsage
async def handle_getStreamUsageBySdkVersion(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getStreamUsageBySdkVersion MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/streams/{source}/bysdkversion.
    Get stream usage by SDK version
    """
    logger.info(f"Handling getStreamUsageBySdkVersion with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/streams/{source}/bysdkversion"
    # Replace path parameter {source}} with the value from params
    if "source" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: source"
        )
    path = path.replace("{source}}", str(params["source"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "tz" in params:
        query_params["tz"] = params["tz"]
    if "sdk" in params:
        query_params["sdk"] = params["sdk"]
    if "version" in params:
        query_params["version"] = params["version"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getStreamUsageBySdkVersion"] = handle_getStreamUsageBySdkVersion
async def handle_getStreamUsageSdkversion(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getStreamUsageSdkversion MCP function.
    
    Makes an HTTP GET request to /api/v2/usage/streams/{source}/sdkversions.
    Get stream usage SDK versions
    """
    logger.info(f"Handling getStreamUsageSdkversion with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/usage/streams/{source}/sdkversions"
    # Replace path parameter {source}} with the value from params
    if "source" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: source"
        )
    path = path.replace("{source}}", str(params["source"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getStreamUsageSdkversion"] = handle_getStreamUsageSdkversion
async def handle_getUserAttributeNames(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getUserAttributeNames MCP function.
    
    Makes an HTTP GET request to /api/v2/user-attributes/{projectKey}/{environmentKey}.
    Get user attribute names
    """
    logger.info(f"Handling getUserAttributeNames with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/user-attributes/{projectKey}/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getUserAttributeNames"] = handle_getUserAttributeNames
async def handle_getSearchUsers(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getSearchUsers MCP function.
    
    Makes an HTTP GET request to /api/v2/user-search/{projectKey}/{environmentKey}.
    Find users
    """
    logger.info(f"Handling getSearchUsers with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/user-search/{projectKey}/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "q" in params:
        query_params["q"] = params["q"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "after" in params:
        query_params["after"] = params["after"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "searchAfter" in params:
        query_params["searchAfter"] = params["searchAfter"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getSearchUsers"] = handle_getSearchUsers
async def handle_getUsers(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getUsers MCP function.
    
    Makes an HTTP GET request to /api/v2/users/{projectKey}/{environmentKey}.
    List users
    """
    logger.info(f"Handling getUsers with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/users/{projectKey}/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "searchAfter" in params:
        query_params["searchAfter"] = params["searchAfter"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getUsers"] = handle_getUsers
async def handle_getUser(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getUser MCP function.
    
    Makes an HTTP GET request to /api/v2/users/{projectKey}/{environmentKey}/{userKey}.
    Get user
    """
    logger.info(f"Handling getUser with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/users/{projectKey}/{environmentKey}/{userKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {userKey}} with the value from params
    if "userKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: userKey"
        )
    path = path.replace("{userKey}}", str(params["userKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getUser"] = handle_getUser
async def handle_deleteUser(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteUser MCP function.
    
    Makes an HTTP DELETE request to /api/v2/users/{projectKey}/{environmentKey}/{userKey}.
    Delete user
    """
    logger.info(f"Handling deleteUser with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/users/{projectKey}/{environmentKey}/{userKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {userKey}} with the value from params
    if "userKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: userKey"
        )
    path = path.replace("{userKey}}", str(params["userKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteUser"] = handle_deleteUser
async def handle_getUserFlagSettings(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getUserFlagSettings MCP function.
    
    Makes an HTTP GET request to /api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags.
    List flag settings for user
    """
    logger.info(f"Handling getUserFlagSettings with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {userKey}} with the value from params
    if "userKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: userKey"
        )
    path = path.replace("{userKey}}", str(params["userKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getUserFlagSettings"] = handle_getUserFlagSettings
async def handle_getUserFlagSetting(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getUserFlagSetting MCP function.
    
    Makes an HTTP GET request to /api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}.
    Get flag setting for user
    """
    logger.info(f"Handling getUserFlagSetting with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {userKey}} with the value from params
    if "userKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: userKey"
        )
    path = path.replace("{userKey}}", str(params["userKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getUserFlagSetting"] = handle_getUserFlagSetting
async def handle_putFlagSetting(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the putFlagSetting MCP function.
    
    Makes an HTTP PUT request to /api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}.
    Update flag settings for user
    """
    logger.info(f"Handling putFlagSetting with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    # Replace path parameter {userKey}} with the value from params
    if "userKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: userKey"
        )
    path = path.replace("{userKey}}", str(params["userKey"]))
    # Replace path parameter {featureFlagKey}} with the value from params
    if "featureFlagKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: featureFlagKey"
        )
    path = path.replace("{featureFlagKey}}", str(params["featureFlagKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["putFlagSetting"] = handle_putFlagSetting
async def handle_getExpiringFlagsForUser(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getExpiringFlagsForUser MCP function.
    
    Makes an HTTP GET request to /api/v2/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}.
    Get expiring dates on flags for user
    """
    logger.info(f"Handling getExpiringFlagsForUser with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {userKey}} with the value from params
    if "userKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: userKey"
        )
    path = path.replace("{userKey}}", str(params["userKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getExpiringFlagsForUser"] = handle_getExpiringFlagsForUser
async def handle_patchExpiringFlagsForUser(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchExpiringFlagsForUser MCP function.
    
    Makes an HTTP PATCH request to /api/v2/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}.
    Update expiring user target for flags
    """
    logger.info(f"Handling patchExpiringFlagsForUser with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {userKey}} with the value from params
    if "userKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: userKey"
        )
    path = path.replace("{userKey}}", str(params["userKey"]))
    # Replace path parameter {environmentKey}} with the value from params
    if "environmentKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: environmentKey"
        )
    path = path.replace("{environmentKey}}", str(params["environmentKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchExpiringFlagsForUser"] = handle_patchExpiringFlagsForUser
async def handle_getVersions(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getVersions MCP function.
    
    Makes an HTTP GET request to /api/v2/versions.
    Get version information
    """
    logger.info(f"Handling getVersions with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/versions"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getVersions"] = handle_getVersions
async def handle_getAllWebhooks(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAllWebhooks MCP function.
    
    Makes an HTTP GET request to /api/v2/webhooks.
    List webhooks
    """
    logger.info(f"Handling getAllWebhooks with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/webhooks"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAllWebhooks"] = handle_getAllWebhooks
async def handle_postWebhook(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postWebhook MCP function.
    
    Makes an HTTP POST request to /api/v2/webhooks.
    Creates a webhook
    """
    logger.info(f"Handling postWebhook with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/webhooks"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postWebhook"] = handle_postWebhook
async def handle_getWebhook(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getWebhook MCP function.
    
    Makes an HTTP GET request to /api/v2/webhooks/{id}.
    Get webhook
    """
    logger.info(f"Handling getWebhook with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/webhooks/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getWebhook"] = handle_getWebhook
async def handle_patchWebhook(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchWebhook MCP function.
    
    Makes an HTTP PATCH request to /api/v2/webhooks/{id}.
    Update webhook
    """
    logger.info(f"Handling patchWebhook with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/webhooks/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchWebhook"] = handle_patchWebhook
async def handle_deleteWebhook(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteWebhook MCP function.
    
    Makes an HTTP DELETE request to /api/v2/webhooks/{id}.
    Delete webhook
    """
    logger.info(f"Handling deleteWebhook with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/webhooks/{id}"
    # Replace path parameter {id}} with the value from params
    if "id" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: id"
        )
    path = path.replace("{id}}", str(params["id"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteWebhook"] = handle_deleteWebhook
async def handle_getTags(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getTags MCP function.
    
    Makes an HTTP GET request to /api/v2/tags.
    List tags
    """
    logger.info(f"Handling getTags with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/tags"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "kind" in params:
        query_params["kind"] = params["kind"]
    if "pre" in params:
        query_params["pre"] = params["pre"]
    if "archived" in params:
        query_params["archived"] = params["archived"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "asOf" in params:
        query_params["asOf"] = params["asOf"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getTags"] = handle_getTags
async def handle_getAIConfigs(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAIConfigs MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/ai-configs.
    List AI Configs
    """
    logger.info(f"Handling getAIConfigs with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "filter" in params:
        query_params["filter"] = params["filter"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAIConfigs"] = handle_getAIConfigs
async def handle_postAIConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postAIConfig MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/ai-configs.
    Create new AI Config
    """
    logger.info(f"Handling postAIConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postAIConfig"] = handle_postAIConfig
async def handle_deleteAIConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteAIConfig MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/ai-configs/{configKey}.
    Delete AI Config
    """
    logger.info(f"Handling deleteAIConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {configKey}} with the value from params
    if "configKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: configKey"
        )
    path = path.replace("{configKey}}", str(params["configKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteAIConfig"] = handle_deleteAIConfig
async def handle_getAIConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAIConfig MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/ai-configs/{configKey}.
    Get AI Config
    """
    logger.info(f"Handling getAIConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {configKey}} with the value from params
    if "configKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: configKey"
        )
    path = path.replace("{configKey}}", str(params["configKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAIConfig"] = handle_getAIConfig
async def handle_patchAIConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchAIConfig MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}/ai-configs/{configKey}.
    Update AI Config
    """
    logger.info(f"Handling patchAIConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {configKey}} with the value from params
    if "configKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: configKey"
        )
    path = path.replace("{configKey}}", str(params["configKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchAIConfig"] = handle_patchAIConfig
async def handle_postAIConfigVariation(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postAIConfigVariation MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/ai-configs/{configKey}/variations.
    Create AI Config variation
    """
    logger.info(f"Handling postAIConfigVariation with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/variations"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {configKey}} with the value from params
    if "configKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: configKey"
        )
    path = path.replace("{configKey}}", str(params["configKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postAIConfigVariation"] = handle_postAIConfigVariation
async def handle_deleteAIConfigVariation(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteAIConfigVariation MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/ai-configs/{configKey}/variations/{variationKey}.
    Delete AI Config variation
    """
    logger.info(f"Handling deleteAIConfigVariation with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/variations/{variationKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {configKey}} with the value from params
    if "configKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: configKey"
        )
    path = path.replace("{configKey}}", str(params["configKey"]))
    # Replace path parameter {variationKey}} with the value from params
    if "variationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: variationKey"
        )
    path = path.replace("{variationKey}}", str(params["variationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteAIConfigVariation"] = handle_deleteAIConfigVariation
async def handle_getAIConfigVariation(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAIConfigVariation MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/ai-configs/{configKey}/variations/{variationKey}.
    Get AI Config variation
    """
    logger.info(f"Handling getAIConfigVariation with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/variations/{variationKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {configKey}} with the value from params
    if "configKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: configKey"
        )
    path = path.replace("{configKey}}", str(params["configKey"]))
    # Replace path parameter {variationKey}} with the value from params
    if "variationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: variationKey"
        )
    path = path.replace("{variationKey}}", str(params["variationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAIConfigVariation"] = handle_getAIConfigVariation
async def handle_patchAIConfigVariation(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchAIConfigVariation MCP function.
    
    Makes an HTTP PATCH request to /api/v2/projects/{projectKey}/ai-configs/{configKey}/variations/{variationKey}.
    Update AI Config variation
    """
    logger.info(f"Handling patchAIConfigVariation with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/variations/{variationKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {configKey}} with the value from params
    if "configKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: configKey"
        )
    path = path.replace("{configKey}}", str(params["configKey"]))
    # Replace path parameter {variationKey}} with the value from params
    if "variationKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: variationKey"
        )
    path = path.replace("{variationKey}}", str(params["variationKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchAIConfigVariation"] = handle_patchAIConfigVariation
async def handle_getAIConfigMetrics(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAIConfigMetrics MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/ai-configs/{configKey}/metrics.
    Get AI Config metrics
    """
    logger.info(f"Handling getAIConfigMetrics with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/metrics"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {configKey}} with the value from params
    if "configKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: configKey"
        )
    path = path.replace("{configKey}}", str(params["configKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: from"
        )
    if "to" in params:
        query_params["to"] = params["to"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: to"
        )
    if "env" in params:
        query_params["env"] = params["env"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: env"
        )
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAIConfigMetrics"] = handle_getAIConfigMetrics
async def handle_getAIConfigMetricsByVariation(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAIConfigMetricsByVariation MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/ai-configs/{configKey}/metrics-by-variation.
    Get AI Config metrics by variation
    """
    logger.info(f"Handling getAIConfigMetricsByVariation with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/metrics-by-variation"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {configKey}} with the value from params
    if "configKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: configKey"
        )
    path = path.replace("{configKey}}", str(params["configKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "from" in params:
        query_params["from"] = params["from"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: from"
        )
    if "to" in params:
        query_params["to"] = params["to"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: to"
        )
    if "env" in params:
        query_params["env"] = params["env"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: env"
        )
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAIConfigMetricsByVariation"] = handle_getAIConfigMetricsByVariation
async def handle_listModelConfigs(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the listModelConfigs MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/ai-configs/model-configs.
    List AI model configs
    """
    logger.info(f"Handling listModelConfigs with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/model-configs"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["listModelConfigs"] = handle_listModelConfigs
async def handle_postModelConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the postModelConfig MCP function.
    
    Makes an HTTP POST request to /api/v2/projects/{projectKey}/ai-configs/model-configs.
    Create an AI model config
    """
    logger.info(f"Handling postModelConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/model-configs"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["postModelConfig"] = handle_postModelConfig
async def handle_deleteModelConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteModelConfig MCP function.
    
    Makes an HTTP DELETE request to /api/v2/projects/{projectKey}/ai-configs/model-configs/{modelConfigKey}.
    Delete an AI model config
    """
    logger.info(f"Handling deleteModelConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/model-configs/{modelConfigKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {modelConfigKey}} with the value from params
    if "modelConfigKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: modelConfigKey"
        )
    path = path.replace("{modelConfigKey}}", str(params["modelConfigKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteModelConfig"] = handle_deleteModelConfig
async def handle_getModelConfig(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getModelConfig MCP function.
    
    Makes an HTTP GET request to /api/v2/projects/{projectKey}/ai-configs/model-configs/{modelConfigKey}.
    Get AI model config
    """
    logger.info(f"Handling getModelConfig with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/projects/{projectKey}/ai-configs/model-configs/{modelConfigKey}"
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    # Replace path parameter {modelConfigKey}} with the value from params
    if "modelConfigKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: modelConfigKey"
        )
    path = path.replace("{modelConfigKey}}", str(params["modelConfigKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    if "LD-API-Version" in params:
        headers["LD-API-Version"] = str(params["LD-API-Version"])
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required header parameter: LD-API-Version"
        )
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getModelConfig"] = handle_getModelConfig
async def handle_getAnnouncementsPublic(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getAnnouncementsPublic MCP function.
    
    Makes an HTTP GET request to /api/v2/announcements.
    Get announcements
    """
    logger.info(f"Handling getAnnouncementsPublic with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/announcements"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "status" in params:
        query_params["status"] = params["status"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getAnnouncementsPublic"] = handle_getAnnouncementsPublic
async def handle_createAnnouncementPublic(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createAnnouncementPublic MCP function.
    
    Makes an HTTP POST request to /api/v2/announcements.
    Create an announcement
    """
    logger.info(f"Handling createAnnouncementPublic with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/announcements"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createAnnouncementPublic"] = handle_createAnnouncementPublic
async def handle_deleteAnnouncementPublic(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteAnnouncementPublic MCP function.
    
    Makes an HTTP DELETE request to /api/v2/announcements/{announcementId}.
    Delete an announcement
    """
    logger.info(f"Handling deleteAnnouncementPublic with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/announcements/{announcementId}"
    # Replace path parameter {announcementId}} with the value from params
    if "announcementId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: announcementId"
        )
    path = path.replace("{announcementId}}", str(params["announcementId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteAnnouncementPublic"] = handle_deleteAnnouncementPublic
async def handle_updateAnnouncementPublic(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the updateAnnouncementPublic MCP function.
    
    Makes an HTTP PATCH request to /api/v2/announcements/{announcementId}.
    Update an announcement
    """
    logger.info(f"Handling updateAnnouncementPublic with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/announcements/{announcementId}"
    # Replace path parameter {announcementId}} with the value from params
    if "announcementId" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: announcementId"
        )
    path = path.replace("{announcementId}}", str(params["announcementId"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["updateAnnouncementPublic"] = handle_updateAnnouncementPublic
async def handle_getDeploymentFrequencyChart(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getDeploymentFrequencyChart MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/charts/deployments/frequency.
    Get deployment frequency chart data
    """
    logger.info(f"Handling getDeploymentFrequencyChart with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/charts/deployments/frequency"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    if "applicationKey" in params:
        query_params["applicationKey"] = params["applicationKey"]
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "bucketType" in params:
        query_params["bucketType"] = params["bucketType"]
    if "bucketMs" in params:
        query_params["bucketMs"] = params["bucketMs"]
    if "groupBy" in params:
        query_params["groupBy"] = params["groupBy"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getDeploymentFrequencyChart"] = handle_getDeploymentFrequencyChart
async def handle_getStaleFlagsChart(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getStaleFlagsChart MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/charts/flags/stale.
    Get stale flags chart data
    """
    logger.info(f"Handling getStaleFlagsChart with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/charts/flags/stale"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: projectKey"
        )
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: environmentKey"
        )
    if "applicationKey" in params:
        query_params["applicationKey"] = params["applicationKey"]
    if "groupBy" in params:
        query_params["groupBy"] = params["groupBy"]
    if "maintainerId" in params:
        query_params["maintainerId"] = params["maintainerId"]
    if "maintainerTeamKey" in params:
        query_params["maintainerTeamKey"] = params["maintainerTeamKey"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getStaleFlagsChart"] = handle_getStaleFlagsChart
async def handle_getFlagStatusChart(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFlagStatusChart MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/charts/flags/status.
    Get flag status chart data
    """
    logger.info(f"Handling getFlagStatusChart with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/charts/flags/status"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: projectKey"
        )
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: environmentKey"
        )
    if "applicationKey" in params:
        query_params["applicationKey"] = params["applicationKey"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFlagStatusChart"] = handle_getFlagStatusChart
async def handle_getLeadTimeChart(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getLeadTimeChart MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/charts/lead-time.
    Get lead time chart data
    """
    logger.info(f"Handling getLeadTimeChart with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/charts/lead-time"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: projectKey"
        )
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    if "applicationKey" in params:
        query_params["applicationKey"] = params["applicationKey"]
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "bucketType" in params:
        query_params["bucketType"] = params["bucketType"]
    if "bucketMs" in params:
        query_params["bucketMs"] = params["bucketMs"]
    if "groupBy" in params:
        query_params["groupBy"] = params["groupBy"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getLeadTimeChart"] = handle_getLeadTimeChart
async def handle_getReleaseFrequencyChart(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getReleaseFrequencyChart MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/charts/releases/frequency.
    Get release frequency chart data
    """
    logger.info(f"Handling getReleaseFrequencyChart with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/charts/releases/frequency"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: projectKey"
        )
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: environmentKey"
        )
    if "applicationKey" in params:
        query_params["applicationKey"] = params["applicationKey"]
    if "hasExperiments" in params:
        query_params["hasExperiments"] = params["hasExperiments"]
    if "global" in params:
        query_params["global"] = params["global"]
    if "groupBy" in params:
        query_params["groupBy"] = params["groupBy"]
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "bucketType" in params:
        query_params["bucketType"] = params["bucketType"]
    if "bucketMs" in params:
        query_params["bucketMs"] = params["bucketMs"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getReleaseFrequencyChart"] = handle_getReleaseFrequencyChart
async def handle_createDeploymentEvent(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createDeploymentEvent MCP function.
    
    Makes an HTTP POST request to /api/v2/engineering-insights/deployment-events.
    Create deployment event
    """
    logger.info(f"Handling createDeploymentEvent with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/deployment-events"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createDeploymentEvent"] = handle_createDeploymentEvent
async def handle_getDeployments(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getDeployments MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/deployments.
    List deployments
    """
    logger.info(f"Handling getDeployments with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/deployments"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: projectKey"
        )
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: environmentKey"
        )
    if "applicationKey" in params:
        query_params["applicationKey"] = params["applicationKey"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "after" in params:
        query_params["after"] = params["after"]
    if "before" in params:
        query_params["before"] = params["before"]
    if "kind" in params:
        query_params["kind"] = params["kind"]
    if "status" in params:
        query_params["status"] = params["status"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getDeployments"] = handle_getDeployments
async def handle_getDeployment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getDeployment MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/deployments/{deploymentID}.
    Get deployment
    """
    logger.info(f"Handling getDeployment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/deployments/{deploymentID}"
    # Replace path parameter {deploymentID}} with the value from params
    if "deploymentID" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: deploymentID"
        )
    path = path.replace("{deploymentID}}", str(params["deploymentID"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getDeployment"] = handle_getDeployment
async def handle_updateDeployment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the updateDeployment MCP function.
    
    Makes an HTTP PATCH request to /api/v2/engineering-insights/deployments/{deploymentID}.
    Update deployment
    """
    logger.info(f"Handling updateDeployment with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/deployments/{deploymentID}"
    # Replace path parameter {deploymentID}} with the value from params
    if "deploymentID" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: deploymentID"
        )
    path = path.replace("{deploymentID}}", str(params["deploymentID"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["updateDeployment"] = handle_updateDeployment
async def handle_getFlagEvents(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getFlagEvents MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/flag-events.
    List flag events
    """
    logger.info(f"Handling getFlagEvents with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/flag-events"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: projectKey"
        )
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: environmentKey"
        )
    if "applicationKey" in params:
        query_params["applicationKey"] = params["applicationKey"]
    if "query" in params:
        query_params["query"] = params["query"]
    if "impactSize" in params:
        query_params["impactSize"] = params["impactSize"]
    if "hasExperiments" in params:
        query_params["hasExperiments"] = params["hasExperiments"]
    if "global" in params:
        query_params["global"] = params["global"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "after" in params:
        query_params["after"] = params["after"]
    if "before" in params:
        query_params["before"] = params["before"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getFlagEvents"] = handle_getFlagEvents
async def handle_createInsightGroup(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the createInsightGroup MCP function.
    
    Makes an HTTP POST request to /api/v2/engineering-insights/insights/group.
    Create insight group
    """
    logger.info(f"Handling createInsightGroup with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/insights/group"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["createInsightGroup"] = handle_createInsightGroup
async def handle_getInsightGroups(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getInsightGroups MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/insights/groups.
    List insight groups
    """
    logger.info(f"Handling getInsightGroups with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/insights/groups"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "offset" in params:
        query_params["offset"] = params["offset"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "query" in params:
        query_params["query"] = params["query"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getInsightGroups"] = handle_getInsightGroups
async def handle_getInsightGroup(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getInsightGroup MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/insights/groups/{insightGroupKey}.
    Get insight group
    """
    logger.info(f"Handling getInsightGroup with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/insights/groups/{insightGroupKey}"
    # Replace path parameter {insightGroupKey}} with the value from params
    if "insightGroupKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: insightGroupKey"
        )
    path = path.replace("{insightGroupKey}}", str(params["insightGroupKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getInsightGroup"] = handle_getInsightGroup
async def handle_patchInsightGroup(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the patchInsightGroup MCP function.
    
    Makes an HTTP PATCH request to /api/v2/engineering-insights/insights/groups/{insightGroupKey}.
    Patch insight group
    """
    logger.info(f"Handling patchInsightGroup with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/insights/groups/{insightGroupKey}"
    # Replace path parameter {insightGroupKey}} with the value from params
    if "insightGroupKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: insightGroupKey"
        )
    path = path.replace("{insightGroupKey}}", str(params["insightGroupKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.patch(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["patchInsightGroup"] = handle_patchInsightGroup
async def handle_deleteInsightGroup(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteInsightGroup MCP function.
    
    Makes an HTTP DELETE request to /api/v2/engineering-insights/insights/groups/{insightGroupKey}.
    Delete insight group
    """
    logger.info(f"Handling deleteInsightGroup with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/insights/groups/{insightGroupKey}"
    # Replace path parameter {insightGroupKey}} with the value from params
    if "insightGroupKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: insightGroupKey"
        )
    path = path.replace("{insightGroupKey}}", str(params["insightGroupKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteInsightGroup"] = handle_deleteInsightGroup
async def handle_getInsightsScores(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getInsightsScores MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/insights/scores.
    Get insight scores
    """
    logger.info(f"Handling getInsightsScores with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/insights/scores"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: projectKey"
        )
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: environmentKey"
        )
    if "applicationKey" in params:
        query_params["applicationKey"] = params["applicationKey"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getInsightsScores"] = handle_getInsightsScores
async def handle_getPullRequests(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getPullRequests MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/pull-requests.
    List pull requests
    """
    logger.info(f"Handling getPullRequests with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/pull-requests"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "projectKey" in params:
        query_params["projectKey"] = params["projectKey"]
    else:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required query parameter: projectKey"
        )
    if "environmentKey" in params:
        query_params["environmentKey"] = params["environmentKey"]
    if "applicationKey" in params:
        query_params["applicationKey"] = params["applicationKey"]
    if "status" in params:
        query_params["status"] = params["status"]
    if "query" in params:
        query_params["query"] = params["query"]
    if "limit" in params:
        query_params["limit"] = params["limit"]
    if "expand" in params:
        query_params["expand"] = params["expand"]
    if "sort" in params:
        query_params["sort"] = params["sort"]
    if "from" in params:
        query_params["from"] = params["from"]
    if "to" in params:
        query_params["to"] = params["to"]
    if "after" in params:
        query_params["after"] = params["after"]
    if "before" in params:
        query_params["before"] = params["before"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getPullRequests"] = handle_getPullRequests
async def handle_getInsightsRepositories(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the getInsightsRepositories MCP function.
    
    Makes an HTTP GET request to /api/v2/engineering-insights/repositories.
    List repositories
    """
    logger.info(f"Handling getInsightsRepositories with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/repositories"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    if "expand" in params:
        query_params["expand"] = params["expand"]
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["getInsightsRepositories"] = handle_getInsightsRepositories
async def handle_associateRepositoriesAndProjects(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the associateRepositoriesAndProjects MCP function.
    
    Makes an HTTP PUT request to /api/v2/engineering-insights/repositories/projects.
    Associate repositories with projects
    """
    logger.info(f"Handling associateRepositoriesAndProjects with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/repositories/projects"
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    if "body" in params:
        request_body = params["body"]
        headers["Content-Type"] = "application/json"
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.put(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["associateRepositoriesAndProjects"] = handle_associateRepositoriesAndProjects
async def handle_deleteRepositoryProject(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handler for the deleteRepositoryProject MCP function.
    
    Makes an HTTP DELETE request to /api/v2/engineering-insights/repositories/{repositoryKey}/projects/{projectKey}.
    Remove repository project association
    """
    logger.info(f"Handling deleteRepositoryProject with params: {params}")
    
    # 1. Construct the target URL
    path = "/api/v2/engineering-insights/repositories/{repositoryKey}/projects/{projectKey}"
    # Replace path parameter {repositoryKey}} with the value from params
    if "repositoryKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: repositoryKey"
        )
    path = path.replace("{repositoryKey}}", str(params["repositoryKey"]))
    # Replace path parameter {projectKey}} with the value from params
    if "projectKey" not in params:
        raise McpError(
            code="MISSING_PARAMETER",
            message="Missing required path parameter: projectKey"
        )
    path = path.replace("{projectKey}}", str(params["projectKey"]))
    
    target_url = config.TARGET_API_BASE_URL.rstrip('/') + path
    
    # 2. Prepare query parameters
    query_params = {}
    
    # 3. Prepare headers
    headers = {
        'Accept': 'application/json'
    }
    
    
    # Add authentication if configured
    # Uncomment and adjust based on your API's authentication requirements
    # if hasattr(config, "TARGET_API_KEY") and config.TARGET_API_KEY:
    #     headers["Authorization"] = f"Bearer {config.TARGET_API_KEY}"
    # or
    #     headers["X-API-Key"] = config.TARGET_API_KEY
    
    # 4. Prepare request body (if applicable)
    request_body = None
    
    # 5. Make the HTTP request to the target API
    try:
        async with aiohttp.ClientSession() as session:
            async with session.delete(
                target_url,
                params=query_params,
                headers=headers,
                json=request_body
            ) as response:
                logger.info(f"Target API response status: {response.status}")
                
                # 6. Process the response
                if 200 <= response.status < 300:  # Successful response
                    try:
                        # Try to parse as JSON
                        result = await response.json()
                        return result
                    except aiohttp.ContentTypeError:
                        # If it's not JSON, return the raw text
                        content = await response.text()
                        return {"content": content}
                else:
                    # Handle error response
                    try:
                        error_data = await response.json()
                        error_detail = json.dumps(error_data)
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        error_detail = await response.text()
                    
                    error_mapping = {
                        400: "BAD_REQUEST",
                        401: "UNAUTHORIZED",
                        403: "FORBIDDEN",
                        404: "NOT_FOUND",
                        429: "RATE_LIMITED",
                        500: "SERVER_ERROR",
                        502: "BAD_GATEWAY",
                        503: "SERVICE_UNAVAILABLE",
                        504: "GATEWAY_TIMEOUT"
                    }
                    
                    error_code = error_mapping.get(response.status, f"HTTP_{response.status}")
                    
                    raise McpError(
                        code=f"TARGET_API_{error_code}",
                        message=f"Target API returned {response.status}",
                        details=error_detail
                    )
    except aiohttp.ClientError as e:
        # Handle connection errors
        logger.error(f"HTTP request error: {e}")
        raise McpError(
            code="CONNECTION_ERROR",
            message=f"Failed to connect to target API: {str(e)}"
        )
    except Exception as e:
        # Handle unexpected errors
        logger.exception(f"Unexpected error in handler: {e}")
        raise McpError(
            code="INTERNAL_ERROR",
            message=f"An unexpected error occurred: {str(e)}"
        )

# Register the handler function
function_handlers["deleteRepositoryProject"] = handle_deleteRepositoryProject
 